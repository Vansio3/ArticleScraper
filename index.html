<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<title>Modern Article Extractor</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="dark light">

<!-- Pico.css -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@latest/css/pico.min.css">

<!-- Favicon Links -->
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="192x192" href="icons/android-chrome-192x192.png">

<!-- Manifest -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#00aeff">

<style>
  :root { --pico-color-amber-500: #ffa000; --pico-color-red-550: #d32f2f; --pico-color-red-600: #c62828; --pico-border-radius-pill: 50px; }
  body { font-family: var(--font-family); margin: 0; padding: var(--pico-spacing); line-height: 1.6; background-color: var(--pico-color-dark-background); color: var(--pico-color); display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow-x: hidden; justify-content: flex-start; }
  main.container { padding: calc(var(--pico-spacing) * 1.5); margin: calc(var(--pico-spacing) * 2) auto var(--pico-spacing) auto; max-width: 700px; width: 90%; transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1); transform: translateY(0); }
  main.container.state-initial { transform: translateY(25vh); }
  #copy-button-wrapper, #extracted-content-details, #status-messages { display: block; opacity: 0; max-height: 0; overflow: hidden; transform: translateY(15px); transition: opacity 0.5s ease-out 0.25s, max-height 0.5s ease-out 0.25s, transform 0.5s ease-out 0.25s; }
  main.container:not(.state-initial) #copy-button-wrapper, main.container:not(.state-initial) #extracted-content-details, main.container:not(.state-initial) #status-messages { opacity: 1; max-height: 1000px; transform: translateY(0); }
  #settings-button { position: fixed; top: var(--pico-spacing); right: var(--pico-spacing); z-index: 100; padding: calc(var(--pico-spacing) * 0.3); width: auto; height: auto; border-radius: 50%; line-height: 0; }
  #settings-button svg { width: 1.1em; height: 1.1em; vertical-align: middle; }

  /* --- START Settings Dialog & Add/Edit Dialog Animation & Backdrop --- */
  dialog#settings-dialog, dialog#add-edit-preset-dialog { max-width: 500px; border-radius: var(--pico-border-radius); padding: 0; opacity: 0; transform: scale(0.95) translateY(10px); transition: opacity 0.25s ease-out, transform 0.25s ease-out, display 0.25s allow-discrete; pointer-events: none; overflow: visible; background: transparent; box-shadow: none; border: none; }
  /* The ::backdrop pseudo-element */
  dialog#settings-dialog::backdrop, dialog#add-edit-preset-dialog::backdrop { background-color: rgba(26, 26, 26, 0); transition: background-color 0.3s ease-out; }
  /* Styles for when the dialog is open */
  dialog#settings-dialog[open], dialog#add-edit-preset-dialog[open] { opacity: 1; transform: scale(1) translateY(0); pointer-events: auto; }
  /* Styles for when the dialog is open - backdrop */
  dialog#settings-dialog[open]::backdrop, dialog#add-edit-preset-dialog[open]::backdrop { background-color: rgba(26, 26, 26, 0.6); }
  /* Ensure article inside dialog gets the styling */
  dialog#settings-dialog > article, dialog#add-edit-preset-dialog > article { background-color: var(--pico-card-background-color); border: 1px solid var(--pico-card-border-color); box-shadow: var(--pico-card-box-shadow); border-radius: var(--pico-border-radius); margin: 0; padding: var(--pico-block-spacing-vertical) var(--pico-block-spacing-horizontal); }
  /* --- END Dialog Animation & Backdrop --- */

  dialog#settings-dialog textarea#prefix-textarea { margin-bottom: var(--pico-spacing); min-height: 80px; }
  dialog#add-edit-preset-dialog textarea#preset-text-display { min-height: 60px; background-color: var(--pico-form-element-background-color); border-color: var(--pico-form-element-border-color); opacity: 0.8; }
  dialog#add-edit-preset-dialog input#preset-title-input { margin-bottom: var(--pico-spacing); }
  dialog#add-edit-preset-dialog label { margin-bottom: calc(var(--pico-spacing) * 0.5); display: block; font-weight: var(--pico-font-weight-semibold); }


  .preset-buttons-container { margin-bottom: calc(var(--pico-spacing) * 1.5); display: flex; flex-wrap: wrap; gap: calc(var(--pico-spacing) * 0.5); align-items: center; }
  .preset-buttons-container small { width: 100%; margin-bottom: calc(var(--pico-spacing) * 0.25); color: var(--pico-secondary); font-size: 0.85em; }
  .preset-buttons-container button { padding: calc(var(--pico-spacing) * 0.4) calc(var(--pico-spacing) * 0.8); font-size: 0.9em; margin: 0; }

  #custom-presets-container { margin-top: var(--pico-spacing); margin-bottom: calc(var(--pico-spacing) * 1.5); }
  #custom-presets-container h6 { margin-bottom: calc(var(--pico-spacing) * 0.5); color: var(--pico-secondary); }

  /* --- START Custom Preset List Layout Changes --- */
  #custom-presets-list {
    display: grid; /* Use grid layout */
    grid-template-columns: 1fr; /* Each item takes one full column */
    gap: calc(var(--pico-spacing) * 0.5); /* Space between rows */
  }
  #custom-presets-list .custom-preset-item {
    display: flex; /* Keep load/edit buttons side-by-side */
    align-items: center; /* Vertically align buttons */
    gap: calc(var(--pico-spacing) * 0.3);
    width: 100%; /* Ensure the item takes full width */
  }
  #custom-presets-list button.preset-load-btn {
    padding: calc(var(--pico-spacing) * 0.4) calc(var(--pico-spacing) * 0.8);
    font-size: 0.9em;
    margin: 0;
    flex-grow: 1; /* Make load button take available space */
    text-align: left;
    overflow: hidden;      /* Prevent text overflow issues */
    text-overflow: ellipsis; /* Add ellipsis if text is too long */
    white-space: nowrap;   /* Keep text on one line */
  }
  #custom-presets-list button.preset-edit-btn {
    padding: calc(var(--pico-spacing) * 0.3);
    width: auto;
    height: auto;
    border-radius: 50%;
    line-height: 0;
    flex-shrink: 0; /* Prevent edit button from shrinking */
    margin: 0; /* Remove all margins, including bottom */
  }
  #custom-presets-list button.preset-edit-btn svg { width: 0.9em; height: 0.9em; vertical-align: middle; }
  /* --- END Custom Preset List Layout Changes --- */

  #no-custom-presets-msg { font-style: italic; color: var(--pico-secondary); font-size: 0.9em; }
  #add-preset-button { margin-top: var(--pico-spacing); display: none; /* Initially hidden */ }

  dialog footer { text-align: right; margin-top: var(--pico-spacing); }
  /* --- START Add/Edit Dialog Footer Layout Changes --- */
  dialog#add-edit-preset-dialog footer {
    display: flex; /* Use flexbox */
    justify-content: flex-end; /* Align buttons to the right by default */
    align-items: center;
    gap: calc(var(--pico-spacing) * 0.5); /* Space between adjacent buttons */
  }
  dialog#add-edit-preset-dialog footer button#delete-custom-preset-button {
      margin-right: auto; /* Pushes delete button to the far left */
  }
  /* --- END Add/Edit Dialog Footer Layout Changes --- */

  dialog header > button[aria-label="Close"] { margin-left: auto; margin-bottom: 0; }
  h1 { font-size: 1.75em; margin-bottom: var(--pico-block-spacing-vertical); text-align: center; }
  #input-group { display: flex; align-items: center; background-color: var(--pico-form-element-background-color); border-radius: var(--pico-border-radius-pill); border: var(--pico-border-width) solid var(--pico-form-element-border-color); padding: 0; overflow: hidden; margin-bottom: var(--pico-block-spacing-vertical); }
  #input-group:focus-within { border-color: var(--pico-primary); box-shadow: 0 0 0 var(--pico-outline-width) var(--pico-primary-focus); }
  #url-input { flex-grow: 1; border: none; background-color: transparent; padding: var(--pico-form-element-spacing-vertical) var(--pico-form-element-spacing-horizontal); padding-right: calc(var(--pico-form-element-spacing-horizontal) / 2); font-size: 1em; color: var(--pico-form-element-color); outline: none !important; box-shadow: none !important; margin: 0; min-width: 0; }
  #url-input::placeholder { color: var(--pico-secondary); }
  #extract-button { flex-shrink: 0; border: none; background-color: var(--pico-primary); color: var(--pico-primary-inverse); margin: 4px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.4em; font-weight: bold; line-height: 1; width: 2.4em; height: 2.4em; padding: 0; transition: background-color var(--pico-transition), transform 0.2s ease-in-out, color 0.1s ease; position: relative; overflow: hidden; transform: rotate(0deg); }
  #extract-button:hover:not([aria-busy=true]):not(.reset-mode) { background-color: var(--pico-primary-hover); }
  #extract-button:active:not([aria-busy=true]):not(.reset-mode) { transform: scale(0.95); }
  #extract-button[aria-busy=true] { background-color: var(--pico-secondary); cursor: default; color: transparent; }
  #extract-button[aria-busy=true]::before { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); margin: 0 !important; }
  #extract-button.reset-mode { background-color: var(--pico-color-red-550); color: #fff; transform: rotate(180deg); }
  #extract-button.reset-mode:hover:not([aria-busy=true]) { background-color: var(--pico-color-red-600); }
  #extract-button.reset-mode:active:not([aria-busy=true]) { transform: rotate(180deg) scale(0.95); }
  #copy-button-wrapper { margin-bottom: calc(var(--pico-spacing) / 2); display: flex; justify-content: center; gap: var(--pico-spacing); flex-wrap: wrap; }
  #copy-button, #share-button { background-color: var(--pico-card-background-color); color: var(--pico-contrast-foreground); border: 1px solid var(--pico-contrast-border); padding: calc(var(--pico-spacing) * 0.6) calc(var(--pico-spacing) * 1.0); border-radius: var(--pico-border-radius); display: inline-flex; align-items: center; justify-content: center; gap: calc(var(--pico-spacing) * 0.5); transition: background-color var(--pico-transition), border-color var(--pico-transition), transform 0.1s ease, box-shadow var(--pico-transition), opacity 0.2s ease; cursor: pointer; font-weight: var(--pico-font-weight-medium); width: auto; display: none; /* Hide initially */ }
  #copy-button.enabled, #share-button.enabled { display: inline-flex; } /* Show if enabled by JS */
  #copy-button .icon-wrapper, #share-button .icon-wrapper { display: inline-flex; align-items: center; line-height: 0; }
  #copy-button svg, #share-button svg { width: 1.1em; height: 1.1em; fill: currentColor; }
  #copy-button:not(:disabled):hover, #share-button:not(:disabled):hover { background-color: var(--pico-contrast-hover-background); border-color: var(--pico-contrast-hover-border); transform: translateY(-1px); box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15); }
  #copy-button:not(:disabled):active, #share-button:not(:disabled):active { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
  #copy-button:disabled, #share-button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; transform: none; background-color: var(--pico-card-background-color); color: var(--pico-contrast-foreground); border-color: var(--pico-contrast-border); }
  #copy-button.secondary { background-color: var(--pico-secondary-background); border-color: var(--pico-secondary-border); color: var(--pico-secondary-foreground); }
  #extracted-text { font-family: var(--pico-font-monospace); height: 250px; resize: vertical; margin-bottom: 0; }
  details summary { font-weight: var(--pico-font-weight-semibold); margin-top: var(--pico-spacing); }
  details > div { padding-top: var(--pico-form-element-spacing-vertical); }
  #status-messages { margin-top: var(--pico-block-spacing-vertical); min-height: 1.5em; text-align: center; font-weight: var(--pico-font-weight-medium); font-size: 0.9em; }
  #error-message { color: var(--pico-color-red-500); }
  #success-message { color: var(--pico-color-green-500); }
  #retry-message { color: var(--pico-color-amber-500); }
  @media (min-width: 768px) { h1 { font-size: 2em; } #extracted-text { height: 300px; } }
  @media (min-width: 992px) { #extracted-text { height: 350px; } }
</style>
</head>
<body data-theme="dark">

<main class="container state-initial">
    <h1>Article Extractor</h1>
    <div id="input-group">
        <input type="text" id="url-input" name="url-input" placeholder="Paste URL or text here...">
        <button id="extract-button" title="Extract Text" aria-label="Extract Text"></button>
    </div>
    <div id="copy-button-wrapper">
       <button id="copy-button" disabled>
            <span class="icon-wrapper"></span>
            <span class="text-wrapper">Copy</span>
       </button>
       <button id="share-button" disabled>
            <span class="icon-wrapper"></span>
           <span class="text-wrapper">Share</span>
       </button>
    </div>
    <details id="extracted-content-details">
        <summary>View Extracted Text</summary>
        <div>
            <textarea id="extracted-text" name="extracted-text" readonly placeholder="Extracted text will appear here..."></textarea>
        </div>
    </details>
    <div id="status-messages">
        <div id="retry-message"></div>
        <div id="error-message"></div>
        <div id="success-message"></div>
    </div>
</main>

<button id="settings-button" class="outline contrast" title="Settings" aria-label="Settings">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
</button>

<!-- Settings Dialog -->
<dialog id="settings-dialog">
    <article>
        <header>
            <button aria-label="Close" rel="prev" id="settings-close-button"></button>
            <strong>Settings</strong>
        </header>
        <form id="settings-form">
             <label for="prefix-textarea">
                Prefix Text (prepended to extracted content):
                <textarea id="prefix-textarea" name="prefix" rows="4" placeholder="Enter text to prepend..."></textarea>
            </label>
            <button type="button" id="add-preset-button" class="outline">Add as Preset</button> <!-- Initially hidden by style/JS -->

            <div class="preset-buttons-container" style="margin-top: var(--pico-spacing);">
                <small>Quick Presets:</small>
                <button type="button" class="outline secondary preset-btn" data-prefix-value="summarise">Summarise</button>
                <button type="button" class="outline secondary preset-btn" data-prefix-value="factcheck">Fact-check</button>
                <button type="button" class="outline secondary preset-btn" data-prefix-value="formatting">Formatting</button>
            </div>

            <div id="custom-presets-container">
                 <h6>Your Presets:</h6>
                 <div id="custom-presets-list">
                     <!-- Custom preset buttons will be added here by JS -->
                 </div>
                 <small id="no-custom-presets-msg" style="display: none;">No custom presets saved yet.</small>
            </div>

            <footer>
                <button type="submit" id="settings-save-button">Save Active Prefix</button>
            </footer>
        </form>
    </article>
</dialog>

<!-- Add/Edit Preset Dialog -->
<dialog id="add-edit-preset-dialog">
    <article>
        <header>
             <button aria-label="Close" rel="prev" class="close-add-edit-preset-dialog"></button>
             <strong id="add-edit-dialog-title">Add New Preset</strong>
        </header>
        <form id="add-edit-preset-form">
             <label for="preset-title-input">Preset Title:</label>
             <input type="text" id="preset-title-input" name="preset-title" placeholder="Short title (max 30 chars)" required maxlength="30">

             <label for="preset-text-display">Preset Text:</label>
             <textarea id="preset-text-display" name="preset-text" readonly rows="3"></textarea>

             <small id="preset-dialog-error" style="color: var(--pico-color-red-500); display: none; margin-bottom: var(--pico-spacing);"></small>

             <footer>
                <button type="button" id="delete-custom-preset-button" class="secondary outline" style="display: none; margin-right: auto;">Delete</button> <!-- Delete button pushed left -->
                <!-- Cancel and Save/Update remain grouped right due to flex-end on footer -->
                <button type="button" class="secondary outline close-add-edit-preset-dialog">Cancel</button>
                <button type="submit" id="save-update-custom-preset-button">Save Preset</button>
            </footer>
        </form>
    </article>
</dialog>


<!-- ***** INCLUDE Readability.js SCRIPT HERE ***** -->
<script src="readability.js"></script>

<script>
    // --- Constants ---
  const PROXY_URL = 'https://api.allorigins.win/raw?url='; const MAX_RETRIES = 3; const RETRY_DELAY_MS = 1500; const DEBOUNCE_DELAY_MS = 500;
  const DEFAULT_TEXT_PREFIX = "Summarise the key points from the following article:\n\n";
  const PREFIX_STORAGE_KEY = 'articleExtractorPrefix';
  const CUSTOM_PREFIXES_STORAGE_KEY = 'articleExtractorCustomPrefixes'; // New key
  const PRESET_SUMMARISE = "Summarise the key points from the following article:";
  const PRESET_FACTCHECK = "I want you to fact check this article in full. Leave no stone unturned. To do so, first, look at the text of the article and parse out each individual fact — after this, you should have a list of facts. Then, for each fact, do comprehensive research to determine whether it is true, false, or unclear. Aim for at least three independent, high quality and trustworthy sources for each fact.\nThen, once you've done this for *every* fact, return a table with each fact and its corresponding results (including sources for each check).";
  const PRESET_FORMATTING = "Fix the punctuation and formatting of the following text:";
  const DEFAULT_PRESETS = {
      summarise: PRESET_SUMMARISE,
      factcheck: PRESET_FACTCHECK,
      formatting: PRESET_FORMATTING
  };

  // --- SVG Icons ---
  const ICON_COPY_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-copy"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>`;
  const ICON_CHECK_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
  const ICON_RESET_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
  const ICON_SHARE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>`;
  const ICON_EDIT_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;

  // --- State Variables ---
  let currentTextPrefix = DEFAULT_TEXT_PREFIX; let isInResetMode = false;
  const isShareSupported = typeof navigator.share === 'function';
  let customPrefixes = []; // To hold { title: '...', prefix: '...' } objects
  let editingPresetIndex = -1; // To track which custom preset is being edited

  // --- Element References ---
  const mainContainer = document.querySelector('main.container'); const urlInput = document.getElementById('url-input'); const extractButton = document.getElementById('extract-button'); const extractedText = document.getElementById('extracted-text'); const copyButton = document.getElementById('copy-button'); const copyButtonIconWrapper = copyButton.querySelector('.icon-wrapper'); const copyButtonTextWrapper = copyButton.querySelector('.text-wrapper'); const shareButton = document.getElementById('share-button'); const shareButtonIconWrapper = shareButton?.querySelector('.icon-wrapper'); const shareButtonTextWrapper = shareButton?.querySelector('.text-wrapper'); const errorMessage = document.getElementById('error-message'); const successMessage = document.getElementById('success-message'); const retryMessage = document.getElementById('retry-message'); const detailsElement = document.getElementById('extracted-content-details'); const copyButtonWrapper = document.getElementById('copy-button-wrapper');
  // Settings Dialog Elements
  const settingsButton = document.getElementById('settings-button'); const settingsDialog = document.getElementById('settings-dialog'); const settingsCloseButton = document.getElementById('settings-close-button'); const settingsForm = document.getElementById('settings-form'); const prefixTextarea = document.getElementById('prefix-textarea'); const settingsSaveButton = document.getElementById('settings-save-button');
  const addPresetButton = document.getElementById('add-preset-button');
  const customPresetsContainer = document.getElementById('custom-presets-container');
  const customPresetsList = document.getElementById('custom-presets-list');
  const noCustomPresetsMsg = document.getElementById('no-custom-presets-msg');
  const presetButtons = settingsDialog.querySelectorAll('.preset-btn'); // Default preset buttons
  // Add/Edit Preset Dialog Elements
  const addEditPresetDialog = document.getElementById('add-edit-preset-dialog');
  const addEditPresetForm = document.getElementById('add-edit-preset-form');
  const addEditDialogTitle = document.getElementById('add-edit-dialog-title');
  const presetTitleInput = document.getElementById('preset-title-input');
  const presetTextDisplay = document.getElementById('preset-text-display');
  const saveUpdateCustomPresetButton = document.getElementById('save-update-custom-preset-button');
  const deleteCustomPresetButton = document.getElementById('delete-custom-preset-button');
  const closeAddEditPresetDialogButtons = document.querySelectorAll('.close-add-edit-preset-dialog');
  const presetDialogError = document.getElementById('preset-dialog-error');

  // --- Debounce Timer ---
  let debounceTimer;

  // --- Storage Functions ---
  function loadActivePrefix() { try { const storedPrefix = localStorage.getItem(PREFIX_STORAGE_KEY); if (storedPrefix !== null) { currentTextPrefix = storedPrefix; console.log("Loaded active prefix from localStorage"); } else { currentTextPrefix = DEFAULT_TEXT_PREFIX; } } catch (e) { console.error("Could not access localStorage for active prefix. Using default.", e); currentTextPrefix = DEFAULT_TEXT_PREFIX; } if (prefixTextarea) prefixTextarea.value = currentTextPrefix; }
  function saveActivePrefix(prefix) { try { localStorage.setItem(PREFIX_STORAGE_KEY, prefix); console.log("Saved active prefix to localStorage"); return true; } catch (e) { console.error("Could not save active prefix to localStorage.", e); return false; } }
  function loadCustomPrefixes() { try { const storedCustom = localStorage.getItem(CUSTOM_PREFIXES_STORAGE_KEY); if (storedCustom) { customPrefixes = JSON.parse(storedCustom); console.log("Loaded custom presets from localStorage"); } else { customPrefixes = []; } } catch (e) { console.error("Could not load/parse custom presets from localStorage.", e); customPrefixes = []; } }
  function saveCustomPrefixes() { try { localStorage.setItem(CUSTOM_PREFIXES_STORAGE_KEY, JSON.stringify(customPrefixes)); console.log("Saved custom presets to localStorage"); return true; } catch (e) { console.error("Could not save custom presets to localStorage.", e); return false; } }

  // --- Initial Setup ---
  function setInitialButtonState() { extractButton.innerHTML = '→'; extractButton.title = 'Extract Text'; extractButton.setAttribute('aria-label', 'Extract Text'); extractButton.classList.remove('reset-mode'); isInResetMode = false; }
  function setInitialCopyIcon() { if (copyButtonIconWrapper) copyButtonIconWrapper.innerHTML = ICON_COPY_SVG; }
  function setInitialShareIcon() { if (isShareSupported && shareButtonIconWrapper) shareButtonIconWrapper.innerHTML = ICON_SHARE_SVG; }
  loadActivePrefix(); loadCustomPrefixes(); // Load both active and custom
  setInitialCopyIcon(); setInitialShareIcon(); setInitialButtonState();
  copyButton.classList.add('enabled'); if (isShareSupported && shareButton) { shareButton.classList.add('enabled'); }

  // --- Render Custom Preset Buttons ---
  function renderCustomPresetButtons() {
      customPresetsList.innerHTML = ''; // Clear existing buttons
      if (customPrefixes.length === 0) {
          noCustomPresetsMsg.style.display = 'block';
      } else {
          noCustomPresetsMsg.style.display = 'none';
          customPrefixes.forEach((preset, index) => {
              const itemDiv = document.createElement('div');
              itemDiv.classList.add('custom-preset-item');

              const loadButton = document.createElement('button');
              loadButton.type = 'button';
              loadButton.classList.add('outline', 'secondary', 'preset-load-btn');
              loadButton.textContent = preset.title;
              loadButton.dataset.index = index; // Store index for loading
              loadButton.title = `Use preset: "${preset.title}"`;
              loadButton.addEventListener('click', handlePresetButtonClick);

              const editButton = document.createElement('button');
              editButton.type = 'button';
              editButton.classList.add('outline', 'secondary', 'preset-edit-btn');
              editButton.title = `Edit preset: "${preset.title}"`;
              editButton.setAttribute('aria-label', `Edit preset: "${preset.title}"`);
              editButton.dataset.index = index; // Store index for editing
              editButton.innerHTML = ICON_EDIT_SVG;
              editButton.addEventListener('click', openEditPresetDialog);

              itemDiv.appendChild(loadButton);
              itemDiv.appendChild(editButton);
              customPresetsList.appendChild(itemDiv);
          });
      }
      // After rendering, check if the current prefix matches any preset for the "Add" button logic
      checkPrefixForAddButtonVisibility();
  }

  // --- Settings Dialog Logic ---
  function openSettings() { if (!settingsDialog) return; prefixTextarea.value = currentTextPrefix; renderCustomPresetButtons(); // Re-render in case presets changed
      checkPrefixForAddButtonVisibility(); // Check button visibility on open
      settingsDialog.showModal(); }
  function closeSettings() { if (!settingsDialog) return; settingsDialog.close(); }
  function handleSettingsBackdropClick(event) { if (event.target === settingsDialog) { closeSettings(); } }
  function saveActivePrefixSettings(event) {
      event.preventDefault(); if (!prefixTextarea) return;
      const newPrefix = prefixTextarea.value;
      const oldPrefix = currentTextPrefix; // Keep old prefix for comparison
      currentTextPrefix = newPrefix;
      if (saveActivePrefix(newPrefix)) {
          displaySuccess("Active prefix saved!");
          setTimeout(clearMessages, 2000);
          // Dynamically update output ONLY if it was using the old prefix
          const currentOutput = extractedText.value;
          if (currentOutput && oldPrefix && currentOutput.startsWith(oldPrefix) && currentOutput.substring(oldPrefix.length).trim().length > 0) {
               const rawTextPart = currentOutput.substring(oldPrefix.length);
               const formattedNewPrefix = currentTextPrefix.trimEnd() + (currentTextPrefix ? "\n\n" : "");
               extractedText.value = formattedNewPrefix + rawTextPart;
               console.log("Dynamically updated displayed text with new active prefix.");
           }
      } else {
          displayError("Could not save active prefix.");
          currentTextPrefix = oldPrefix; // Revert if save failed
      }
      closeSettings();
  }

  // --- Add/Edit Preset Dialog Logic ---
  function openAddPresetDialog() {
      editingPresetIndex = -1; // Ensure we are in "add" mode
      const currentPrefixValue = prefixTextarea.value;
      if (!currentPrefixValue.trim()) {
           // Show error within settings dialog temporarily
           displayError("Cannot save an empty prefix.");
           setTimeout(clearMessages, 2500);
           return;
      }
      presetTitleInput.value = '';
      presetTextDisplay.value = currentPrefixValue;
      addEditDialogTitle.textContent = 'Add New Preset';
      saveUpdateCustomPresetButton.textContent = 'Save Preset';
      deleteCustomPresetButton.style.display = 'none';
      presetDialogError.style.display = 'none'; // Hide errors
      presetTitleInput.removeAttribute('aria-invalid');
      addEditPresetDialog.showModal();
      presetTitleInput.focus(); // Focus title field
  }

  function openEditPresetDialog(event) {
      const button = event.currentTarget;
      const index = parseInt(button.dataset.index, 10);
      if (isNaN(index) || index < 0 || index >= customPrefixes.length) {
          console.error("Invalid index for editing preset:", button.dataset.index);
          // Show error within settings dialog temporarily
          displayError("Error trying to edit preset.");
          setTimeout(clearMessages, 2500);
          return;
      }
      editingPresetIndex = index;
      const preset = customPrefixes[index];

      presetTitleInput.value = preset.title;
      presetTextDisplay.value = preset.prefix;
      addEditDialogTitle.textContent = 'Edit Preset';
      saveUpdateCustomPresetButton.textContent = 'Update Preset';
      deleteCustomPresetButton.style.display = 'inline-flex'; // Show delete button using flex for alignment consistency
      presetDialogError.style.display = 'none';
      presetTitleInput.removeAttribute('aria-invalid');
      addEditPresetDialog.showModal();
      presetTitleInput.focus(); // Focus title field
  }

  function closeAddEditPresetDialog() {
      if (!addEditPresetDialog) return;
      addEditPresetDialog.close();
      editingPresetIndex = -1; // Reset editing state
  }

  function handleAddEditPresetBackdropClick(event) {
      if (event.target === addEditPresetDialog) {
          closeAddEditPresetDialog();
      }
  }

  function handleSaveUpdateCustomPreset(event) {
      event.preventDefault();
      const title = presetTitleInput.value.trim();
      const prefix = presetTextDisplay.value; // Prefix might intentionally have whitespace

      // Validation
      if (!title) {
          presetDialogError.textContent = "Preset title cannot be empty.";
          presetDialogError.style.display = 'block';
          presetTitleInput.setAttribute('aria-invalid', 'true');
          presetTitleInput.focus();
          return;
      }
       if (title.length > 30) { // Redundant due to maxlength, but good practice
          presetDialogError.textContent = "Preset title exceeds 30 characters.";
          presetDialogError.style.display = 'block';
          presetTitleInput.setAttribute('aria-invalid', 'true');
          presetTitleInput.focus();
          return;
      }
       // Check for duplicate titles (case-insensitive)
      const isDuplicateTitle = customPrefixes.some((p, i) =>
            p.title.toLowerCase() === title.toLowerCase() && i !== editingPresetIndex
      );
      if (isDuplicateTitle) {
           presetDialogError.textContent = "A preset with this title already exists.";
           presetDialogError.style.display = 'block';
           presetTitleInput.setAttribute('aria-invalid', 'true');
           presetTitleInput.focus();
           return;
      }

      presetDialogError.style.display = 'none';
      presetTitleInput.removeAttribute('aria-invalid');

      const newPreset = { title: title, prefix: prefix };
      let successMessageText = "";

      if (editingPresetIndex === -1) { // Adding new preset
          customPrefixes.push(newPreset);
          successMessageText = "Custom preset saved!";
      } else { // Updating existing preset
          customPrefixes[editingPresetIndex] = newPreset;
          successMessageText = "Custom preset updated!";
      }

      if (saveCustomPrefixes()) {
          renderCustomPresetButtons(); // Update list in settings dialog
          closeAddEditPresetDialog();
          // Set the newly added/edited prefix as active
          setPrefix(newPreset.prefix);
          saveActivePrefix(newPreset.prefix); // Also save it as the active one
          // Display success message in main UI area
          displaySuccess(successMessageText);
          setTimeout(clearMessages, 2500);
      } else {
          presetDialogError.textContent = "Failed to save presets.";
          presetDialogError.style.display = 'block';
          // Revert changes in memory if save failed? For simplicity, we don't here.
          if (editingPresetIndex === -1) customPrefixes.pop(); // Remove if add failed
          // else // If update failed, the old value is overwritten in memory but not saved
      }
  }

  function handleDeleteCustomPreset() {
      if (editingPresetIndex === -1 || editingPresetIndex >= customPrefixes.length) {
          console.error("Invalid index for deleting preset:", editingPresetIndex);
          // Display error in main UI, as dialog will close
          displayError("Error trying to delete preset.");
          setTimeout(clearMessages, 2500);
          closeAddEditPresetDialog(); // Close dialog even on initial index error
          return;
      }

      const presetToDelete = customPrefixes[editingPresetIndex];
      const presetTitle = presetToDelete.title;
      // Confirmation dialog
      if (!confirm(`Are you sure you want to delete the preset "${presetTitle}"?`)) {
          // Don't close the dialog if user cancels the confirmation
          return;
      }

      // --- Dialog Closing Logic Moved Here ---
      closeAddEditPresetDialog();
      // --- End Change ---

      // Remember the index before splicing
      const deletedIndex = editingPresetIndex;
      // Remove the preset from the array in memory
      customPrefixes.splice(deletedIndex, 1);

      // Attempt to save the updated list
      if (saveCustomPrefixes()) {
          // Actions on successful save:
          renderCustomPresetButtons(); // Update list in settings dialog (will be seen next time it opens)

           // Check if the deleted prefix was the currently active one
           if (currentTextPrefix === presetToDelete.prefix) {
               currentTextPrefix = DEFAULT_TEXT_PREFIX; // Revert to default
               prefixTextarea.value = currentTextPrefix; // Update textarea in settings (if open)
               saveActivePrefix(currentTextPrefix); // Save the default as active
               console.log("Deleted active prefix, reverted to default.");
           }
           // Display success message in main UI area
           displaySuccess(`Preset "${presetTitle}" deleted.`);
           setTimeout(clearMessages, 2500);
      } else {
          // Actions on failed save:
          // Re-add the preset to memory at the original index to keep state consistent
          customPrefixes.splice(deletedIndex, 0, presetToDelete);
          // Display error in main UI area (dialog is already closed)
          displayError(`Failed to permanently delete preset "${presetTitle}". Please try again.`);
          setTimeout(clearMessages, 3000);
          // Re-render buttons in settings in case it's still somehow open or for next open
          renderCustomPresetButtons();
      }
      editingPresetIndex = -1; // Explicitly reset index after operation attempt
  }


  // --- Handle Preset Button Clicks (Default & Custom Load) ---
  function handlePresetButtonClick(event) {
      const button = event.currentTarget;
      let prefixValueToSet = undefined; // Use undefined to signal no match

      if (button.classList.contains('preset-load-btn')) { // Custom preset load button
          const index = parseInt(button.dataset.index, 10);
           if (!isNaN(index) && index >= 0 && index < customPrefixes.length) {
                prefixValueToSet = customPrefixes[index].prefix;
           } else {
               console.error("Invalid index for custom preset button:", button.dataset.index);
               return; // Do nothing if index is bad
           }
      } else if (button.dataset.prefixValue) { // Default preset button
          const presetKey = button.dataset.prefixValue;
          prefixValueToSet = DEFAULT_PRESETS[presetKey]; // Will be undefined if key doesn't exist
      }

      if (prefixValueToSet !== undefined) {
          setPrefix(prefixValueToSet);
          // Maybe close the settings dialog after selecting a preset? Optional.
          // closeSettings();
      } else {
          console.warn("Could not determine prefix value for clicked button:", button);
      }
  }

  // --- Set Prefix Function (Updates textarea and checks Add button) ---
  function setPrefix(prefixValue) {
      if (prefixTextarea) {
          prefixTextarea.value = prefixValue;
          // Trigger input event manually to update "Add Preset" button visibility
          prefixTextarea.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
      }
  }

  // --- Check "Add as Preset" Button Visibility ---
  function checkPrefixForAddButtonVisibility() {
      if (!prefixTextarea || !addPresetButton) return;

      const currentInputPrefix = prefixTextarea.value.trim();
      if (!currentInputPrefix) {
          addPresetButton.style.display = 'none'; // Hide if empty
          return;
      }

      // Get all existing preset values (trimmed)
      const existingPrefixValues = [
          ...Object.values(DEFAULT_PRESETS).map(p => p.trim()),
          ...customPrefixes.map(p => p.prefix.trim())
      ];

      // Check if current input matches any existing (whitespace insensitive)
      const isExisting = existingPrefixValues.includes(currentInputPrefix);

      if (isExisting) {
          addPresetButton.style.display = 'none';
      } else {
          addPresetButton.style.display = 'block';
      }
  }


  // --- NAMED EVENT HANDLERS ---
  function triggerExtractionDebounced() { if (extractButton.getAttribute('aria-busy') === 'true' || isInResetMode) return; clearTimeout(debounceTimer); debounceTimer = setTimeout(handleExtraction, DEBOUNCE_DELAY_MS); }
  function triggerReset() { resetUI(); }

  // --- Share Handler ---
  async function handleShare() { if (!isShareSupported || shareButton.disabled) return; const textToShare = extractedText.value; if (!textToShare || !textToShare.trim()) { displayError("Nothing to share."); return; } try { await navigator.share({ text: textToShare }); console.log('Content shared successfully'); } catch (err) { if (err.name === 'AbortError') { console.log('Share dialog dismissed by user.'); } else { console.error('Error sharing:', err); displayError(`Share failed: ${err.message}`); } } }

  // --- Event Listeners ---
  settingsButton?.addEventListener('click', openSettings);
  settingsCloseButton?.addEventListener('click', closeSettings);
  settingsDialog?.addEventListener('click', handleSettingsBackdropClick);
  settingsForm?.addEventListener('submit', saveActivePrefixSettings); // Changed target function
  // Add listeners for default preset buttons
  presetButtons.forEach(button => button.addEventListener('click', handlePresetButtonClick));
  // Listener for the prefix textarea to check for Add button visibility
  prefixTextarea?.addEventListener('input', checkPrefixForAddButtonVisibility);
  // Listener for the "Add as Preset" button
  addPresetButton?.addEventListener('click', openAddPresetDialog);
  // Listeners for Add/Edit Preset Dialog
  addEditPresetDialog?.addEventListener('click', handleAddEditPresetBackdropClick);
  addEditPresetForm?.addEventListener('submit', handleSaveUpdateCustomPreset);
  deleteCustomPresetButton?.addEventListener('click', handleDeleteCustomPreset);
  closeAddEditPresetDialogButtons.forEach(btn => btn.addEventListener('click', closeAddEditPresetDialog));
  // Main App Listeners
  extractButton.addEventListener('click', triggerExtractionDebounced);
  urlInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); if (extractButton.getAttribute('aria-busy') === 'true' || isInResetMode) return; triggerExtractionDebounced(); } });
  copyButton.addEventListener('click', copyTextToClipboard);
  if (isShareSupported && shareButton) { shareButton.addEventListener('click', handleShare); }

  // --- Core Logic (Fetch, Extract, etc. - including text handling improvement) ---
  function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
  async function fetchWithRetries(url, options, retries = MAX_RETRIES) { for (let i = 0; i <= retries; i++) { try { if (i > 0) { displayRetryMessage(`Attempt ${i+1} of ${retries+1}...`); await delay(RETRY_DELAY_MS * i); } const response = await fetch(url, options); if (!response.ok) { if (response.status >= 500 && response.status < 600 && i < retries) { console.warn(`Attempt ${i+1} failed with status ${response.status}. Retrying...`); continue; } throw new Error(`Proxy fetch failed: ${response.status} ${response.statusText}`); } clearRetryMessage(); return response; } catch (error) { console.error(`Attempt ${i+1} caught error:`, error); if (i === retries) { clearRetryMessage(); throw error; } } } throw new Error("Fetch failed after all retries."); }

  async function handleExtraction() {
    clearMessages(); updateActionButtonsState('');
    const inputText = urlInput.value.trim(); if (!inputText) { displayError("Please enter text or a URL."); return; } // Changed error message slightly

    const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
    let match = inputText.match(urlRegex);
    const looksLikeUrl = inputText.startsWith('http://') || inputText.startsWith('https://');

    // Scenario 1: Input is clearly not a URL and doesn't contain one
    if (!match && !looksLikeUrl) {
        console.log("Input is plain text, applying prefix directly.");
        const rawExtractedText = inputText; // Use the input directly as text
        const formattedPrefix = currentTextPrefix.trimEnd() + (currentTextPrefix && !currentTextPrefix.trimEnd().endsWith('\n\n') ? "\n\n" : "");
        extractedText.value = formattedPrefix + rawExtractedText;
        displaySuccess(`Applied prefix to input text.`);
        updateActionButtonsState(rawExtractedText);
        mainContainer.classList.remove('state-initial');
        detailsElement.open = true;
        // Set reset mode even for direct text input
        extractButton.innerHTML = ICON_RESET_SVG; extractButton.classList.add('reset-mode'); extractButton.title = 'Reset'; extractButton.setAttribute('aria-label', 'Reset'); isInResetMode = true;
        extractButton.removeEventListener('click', triggerExtractionDebounced);
        extractButton.addEventListener('click', triggerReset);
        setLoadingState(false); // Ensure loading stops
        return; // Stop further processing
    }

    // Scenario 2: Input looks like a URL or contains one
    let targetUrl;
    if (match) {
        targetUrl = match[0]; // Use the first matched URL
        console.log("Extracted URL:", targetUrl);
    } else if (looksLikeUrl) {
        // It starts with http but regex failed (maybe invalid chars?) - try using the whole string
        console.warn("Input looks like URL but regex failed, attempting extraction with full input:", inputText);
        targetUrl = inputText;
    } else {
        // This case should technically not be reached due to the first check, but as a fallback:
        displayError("Could not identify a valid URL in the input.");
        return;
    }

    // Proceed with URL extraction
    const proxiedUrl = PROXY_URL + encodeURIComponent(targetUrl); setLoadingState(true);
    try {
        const response = await fetchWithRetries(proxiedUrl); const html = await response.text(); let doc; try { const parser = new DOMParser(); doc = parser.parseFromString(html, 'text/html'); } catch (parseError) { console.error("DOM Parsing Error:", parseError); throw new Error("Failed to parse the HTML content."); } let article = null; if (typeof Readability === 'undefined') { console.warn("Readability.js not loaded. Falling back."); } else { try { const documentClone = doc.cloneNode(true); let reader = new Readability(documentClone); article = reader.parse(); } catch (readabilityError) { console.error("Readability Error:", readabilityError); } } let extractionSource = ''; let rawExtractedText = '';
        if (article && article.textContent && article.textContent.trim().length > 100) { const title = article.title?.trim(); const bodyText = article.textContent.trim(); if (title) { rawExtractedText = `${title}\n\n${bodyText}`; } else { rawExtractedText = bodyText; } extractionSource = 'Readability'; }
        else { if (extractionSource === '') { if (!article && typeof Readability !== 'undefined') console.log("Readability failed/insufficient, attempting fallback..."); else if (typeof Readability === 'undefined') {} else console.log("Readability content insufficient, attempting fallback..."); } const mainElement = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.post-content') || doc.querySelector('.entry-content') || doc.body; if (mainElement) { const scripts = mainElement.querySelectorAll('script, style, nav, header, footer, aside, .sidebar, .ads, [aria-hidden="true"], noscript, form, button, input, figure, figcaption, .share-buttons, .comments-area'); scripts.forEach(el => el.remove()); rawExtractedText = mainElement.textContent.replace(/[\t\r\n]+/g, '\n').replace(/\n\s*\n/g, '\n\n').replace(/ {2,}/g, ' ').trim(); } else { rawExtractedText = doc.body ? doc.body.textContent.trim().replace(/\s\s+/g, ' ') : ''; } if (rawExtractedText.trim().length > 50) { if (!article && typeof Readability !== 'undefined') extractionSource = 'basic fallback (Readability failed)'; else extractionSource = 'basic fallback'; } else { rawExtractedText = ''; } }

        if (extractionSource) {
            const formattedPrefix = currentTextPrefix.trimEnd() + (currentTextPrefix ? "\n\n" : ""); // Use currentTextPrefix
            extractedText.value = formattedPrefix + rawExtractedText;
            displaySuccess(`Extracted using ${extractionSource}.`);
            updateActionButtonsState(rawExtractedText);
            mainContainer.classList.remove('state-initial');
            detailsElement.open = true;
            extractButton.innerHTML = ICON_RESET_SVG; extractButton.classList.add('reset-mode'); extractButton.title = 'Reset'; extractButton.setAttribute('aria-label', 'Reset'); isInResetMode = true;
            extractButton.removeEventListener('click', triggerExtractionDebounced);
            extractButton.addEventListener('click', triggerReset);
        } else { extractedText.value = ''; let finalError = "Extraction failed: Could not get meaningful content."; if (typeof Readability === 'undefined'){ finalError = "Extraction failed: Readability script missing & fallback failed."; } displayError(finalError); if (!mainContainer.classList.contains('state-initial')) mainContainer.classList.add('state-initial'); setInitialButtonState(); extractButton.removeEventListener('click', triggerReset); extractButton.addEventListener('click', triggerExtractionDebounced); updateActionButtonsState(''); detailsElement.open = false; }
    } catch (error) { console.error("Error during fetch or extraction:", error); extractedText.value = ''; displayError(`Error: ${error.message}`); if (!mainContainer.classList.contains('state-initial')) mainContainer.classList.add('state-initial'); setInitialButtonState(); extractButton.removeEventListener('click', triggerReset); extractButton.addEventListener('click', triggerExtractionDebounced); updateActionButtonsState(''); detailsElement.open = false; }
    finally { setLoadingState(false); }
  }

   function setLoadingState(isLoading) { if (isLoading) { extractButton.setAttribute('aria-busy', 'true'); } else { extractButton.removeAttribute('aria-busy'); } }

  // --- Clipboard and UI Functions ---
  function copyTextToClipboard() { if (!extractedText.value) { displayError("Nothing to copy."); return; } if (!detailsElement.open) { detailsElement.open = true; } navigator.clipboard.writeText(extractedText.value) .then(() => { displaySuccess("Content copied to clipboard!"); if (copyButtonIconWrapper) copyButtonIconWrapper.innerHTML = ICON_CHECK_SVG; if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copied!'; copyButton.classList.add('secondary'); setTimeout(() => { setInitialCopyIcon(); if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy'; copyButton.classList.remove('secondary'); }, 2000); }) .catch(err => { console.error('Failed to copy text: ', err); try { detailsElement.open = true; extractedText.select(); document.execCommand('copy'); displaySuccess("Copied (using fallback)!"); } catch (execErr) { displayError("Failed to copy automatically."); } }); }
  function resetUI() {
    clearMessages(); setLoadingState(false); urlInput.value = '';
    updateActionButtonsState('');
    setInitialCopyIcon(); if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy'; copyButton.classList.remove('secondary');
    setInitialShareIcon(); if (isShareSupported && shareButtonTextWrapper) shareButtonTextWrapper.textContent = 'Share';
    detailsElement.open = false; extractedText.value = '';
    mainContainer.classList.add('state-initial');
    setInitialButtonState();
    extractButton.removeEventListener('click', triggerReset);
    extractButton.addEventListener('click', triggerExtractionDebounced);
    // No prefix reset needed here, user manages prefix via settings
  }
  function displayError(message) { errorMessage.textContent = message; successMessage.textContent = ''; retryMessage.textContent = ''; }
  function displaySuccess(message) { successMessage.textContent = message; errorMessage.textContent = ''; retryMessage.textContent = ''; }
  function displayRetryMessage(message) { retryMessage.textContent = message; errorMessage.textContent = ''; successMessage.textContent = ''; }
  function clearRetryMessage() { retryMessage.textContent = ''; }
  function clearMessages() { errorMessage.textContent = ''; successMessage.textContent = ''; retryMessage.textContent = '';}
  function updateActionButtonsState(rawText) {
      const hasContent = rawText && rawText.trim().length > 0;
      copyButton.disabled = !hasContent;
      if (isShareSupported && shareButton) {
          shareButton.disabled = !hasContent;
      }
  }


  // --- PWA Service Worker Registration ---
  if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/ArticleScraper/sw.js') /* Adjust path if needed */ .then(registration => { console.log('ServiceWorker registration successful with scope: ', registration.scope); }) .catch(err => { console.error('ServiceWorker registration failed: ', err); }); }); }
  // --- END PWA Service Worker Registration ---

  // --- HANDLE INCOMING SHARE TARGET ---
  function handleIncomingShare() {
      const urlParams = new URLSearchParams(window.location.search); const sharedUrl = urlParams.get('url'); const sharedText = urlParams.get('text'); let textToInput = '';
      if (sharedUrl) { console.log("Received shared URL:", sharedUrl); textToInput = sharedUrl; }
      else if (sharedText) { console.log("Received shared text:", sharedText); const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i; const match = sharedText.match(urlRegex); if (match) { textToInput = match[0]; console.log("Extracted URL from shared text:", textToInput); } else { textToInput = sharedText; } } // Use text directly if no URL found
      if (textToInput && urlInput) {
          urlInput.value = textToInput;
          console.log("Populated input field with shared data.");
          // Check if it's likely a URL before auto-triggering
          if (textToInput.match(/https?:\/\/[^\s/$.?#].[^\s]*/i) || textToInput.startsWith('http')) {
             console.log("Auto-triggering extraction from share...");
             triggerExtractionDebounced();
          } else {
              console.log("Shared data is likely text, not auto-triggering extraction. User can press Extract.");
              // User can manually press Extract if they want to apply prefix to shared text
          }
      }
  }
  window.addEventListener('load', handleIncomingShare);
  // --- END INCOMING SHARE TARGET ---

</script>

</body>
</html>