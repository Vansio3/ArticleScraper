<!DOCTYPE html>
<html lang="en">
<head>
<title>Dark Article Extractor</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="dark"> <!-- Hint OS about dark theme preference -->

<style>
  /* --- Modern Dark Theme & Mobile First Base --- */
  :root {
    --bg-color: #1a1a1a; /* Dark background */
    --surface-color: #2c2c2c; /* Slightly lighter surface for cards/inputs */
    --surface-hover: #383838;
    --primary-color: #00aeff; /* Vibrant blue accent */
    --primary-hover-color: #0095cc;
    --text-color: #e0e0e0; /* Light text */
    --text-secondary-color: #a0a0a0; /* Dimmer text */
    --border-color: #444444;
    --error-color: #ff5555;
    --success-color: #44dd88;
    --disabled-color: #555555;
    --border-radius: 6px;
    --spacing-unit: 16px;
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html {
      color-scheme: dark; /* Apply dark theme preference */
  }

  body {
    font-family: var(--font-family);
    margin: 0;
    padding: var(--spacing-unit);
    line-height: 1.6;
    background-color: var(--bg-color);
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
  }

  .container {
     width: 100%;
     max-width: 650px; /* Slightly narrower for modern feel */
     background-color: var(--surface-color);
     padding: calc(var(--spacing-unit) * 1.5);
     border-radius: calc(var(--border-radius) * 1.5);
     border: 1px solid var(--border-color);
     margin-bottom: var(--spacing-unit);
     /* Subtle shadow for depth */
     box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  h1 {
    color: var(--text-color); /* Lighter heading */
    text-align: center;
    font-size: 1.8em;
    margin-bottom: calc(var(--spacing-unit) * 1.5);
    font-weight: 600; /* Slightly bolder */
  }

  label {
    display: block;
    margin-bottom: calc(var(--spacing-unit) / 2.5);
    font-weight: 500; /* Medium weight */
    font-size: 0.9em;
    color: var(--text-secondary-color); /* Dimmer label text */
  }

  #input-area {
      display: flex;
      flex-direction: column;
      gap: calc(var(--spacing-unit) / 1.5);
      margin-bottom: var(--spacing-unit); /* Space before next section */
  }

  #url-input {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.7);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 1em;
    background-color: var(--bg-color); /* Match body background */
    color: var(--text-color);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  #url-input::placeholder {
      color: var(--text-secondary-color);
      opacity: 0.7;
  }
  #url-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(0, 174, 255, 0.3); /* Focus ring */
  }

  /* Base Button Styles */
  .button {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.75) var(--spacing-unit);
    cursor: pointer;
    background-color: var(--primary-color);
    color: #ffffff; /* Pure white on accent */
    border: none;
    border-radius: var(--border-radius);
    font-size: 1em;
    font-weight: 600;
    text-align: center;
    transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
  }

  .button:hover:not(:disabled) {
    background-color: var(--primary-hover-color);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
  }

  .button:active:not(:disabled) {
      transform: scale(0.98);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }

  .button:disabled {
    background-color: var(--disabled-color);
    color: var(--text-secondary-color);
    cursor: not-allowed;
    box-shadow: none;
  }

  #loading-indicator {
    display: none;
    margin: var(--spacing-unit) 0;
    text-align: center;
    font-style: italic;
    color: var(--text-secondary-color);
  }

  /* --- Output Area Styling --- */
  #output-container {
    margin-top: var(--spacing-unit); /* Space above the output section */
  }

  /* Style the <summary> element like a clickable header/button */
  #extracted-content-details summary {
      cursor: pointer;
      padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.8);
      background-color: var(--surface-hover); /* Slightly different bg */
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      margin-top: calc(var(--spacing-unit) / 1.5); /* Space below copy button */
      list-style: none; /* Remove default marker */
      display: flex; /* Use flex to align text and custom marker */
      justify-content: space-between;
      align-items: center;
      transition: background-color 0.2s ease;
      font-weight: 500;
  }

  #extracted-content-details summary::-webkit-details-marker {
      display: none; /* Hide marker for Webkit */
  }

  #extracted-content-details summary:hover {
      background-color: #4a4a4a;
  }

  /* Custom dropdown arrow */
  #extracted-content-details summary::after {
      content: 'â–¼'; /* Down arrow when closed */
      font-size: 0.8em;
      margin-left: calc(var(--spacing-unit) / 2);
      color: var(--text-secondary-color);
      transition: transform 0.2s ease-in-out;
  }

  #extracted-content-details[open] summary::after {
      transform: rotate(180deg); /* Up arrow when open */
  }

  /* Content inside the details (textarea) */
  #extracted-content-details > div {
      padding-top: calc(var(--spacing-unit) / 1.5); /* Space between summary and textarea */
  }

  #extracted-text {
    width: 100%;
    height: 250px;
    padding: calc(var(--spacing-unit) * 0.7);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-family: monospace;
    white-space: pre-wrap;
    font-size: 0.9em;
    background-color: var(--bg-color); /* Match body */
    color: var(--text-color);
    resize: vertical;
  }
  #extracted-text:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(0, 174, 255, 0.3);
  }

  #status-messages {
      margin-top: var(--spacing-unit);
      min-height: 1.5em;
      text-align: center;
      font-weight: 500;
      font-size: 0.9em;
  }

  #error-message {
    color: var(--error-color);
  }

  #success-message {
    color: var(--success-color);
  }

  /* --- Tablet & Larger Screens --- */
  @media (min-width: 600px) {
    h1 {
        font-size: 2em;
    }

    .container {
        padding: calc(var(--spacing-unit) * 1.8);
    }

    #input-area {
        flex-direction: row;
        align-items: center;
    }

    #url-input {
        flex-grow: 1;
    }

    #extract-button {
        width: auto; /* Button takes its natural width */
        flex-shrink: 0;
    }

    #extracted-text {
        height: 300px;
        font-size: 0.95em;
    }

    /* Make copy button auto-width on larger screens too */
    #copy-button {
        width: auto;
        display: inline-block; /* Allows centering via text-align on parent */
    }
     /* Center the copy button */
    #output-container > div:first-of-type { /* Target the div holding the copy button */
       text-align: center;
    }
  }

  /* Desktops and up */
  @media (min-width: 992px) {
     .container {
        padding: calc(var(--spacing-unit) * 2.2);
     }
     #extracted-text {
        height: 350px;
     }
  }

</style>
</head>
<body>

<div class="container">
    <h1>Dark Article Extractor</h1>

    <div id="input-container">
      <label for="url-input">Enter URL or text containing a URL:</label>
      <div id="input-area">
          <input type="text" id="url-input" placeholder="e.g., https://example.com/article">
          <!-- Added 'button' class -->
          <button id="extract-button" class="button">Extract Text</button>
      </div>
    </div>

    <div id="loading-indicator">
        Fetching and processing content...
    </div>

    <div id="output-container">
      <!-- Div to help center button on wider screens -->
      <div>
         <!-- Copy button moved here, added 'button' class -->
         <button id="copy-button" class="button" disabled>Copy Extracted Text</button>
      </div>

      <!-- Collapsible section for the text area -->
      <details id="extracted-content-details">
          <summary>View Extracted Text</summary>
          <!-- Div needed inside details for padding -->
          <div>
              <textarea id="extracted-text" readonly placeholder="Extracted text will appear here..."></textarea>
          </div>
      </details>
    </div>

    <div id="status-messages">
        <div id="error-message"></div>
        <div id="success-message"></div>
    </div>
</div> <!-- End .container -->


<!--
    **IMPORTANT: Include Readability.js here**
    (Instructions remain the same)
-->
<!-- <script src="readability.js"></script> -->


<script>
  // Get reference to the new details element
  const urlInput = document.getElementById('url-input');
  const extractButton = document.getElementById('extract-button');
  const loadingIndicator = document.getElementById('loading-indicator');
  const extractedText = document.getElementById('extracted-text');
  const copyButton = document.getElementById('copy-button');
  const errorMessage = document.getElementById('error-message');
  const successMessage = document.getElementById('success-message');
  const detailsElement = document.getElementById('extracted-content-details'); // Added

  extractButton.addEventListener('click', handleExtraction);
  copyButton.addEventListener('click', copyTextToClipboard);

  function handleExtraction() {
    resetUI(); // Reset UI including closing details

    const inputText = urlInput.value.trim();
    if (!inputText) {
        displayError("Please enter text containing a URL.");
        return;
    }

    const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
    const match = inputText.match(urlRegex);

    if (!match) {
      displayError("No valid URL found in the input.");
      return;
    }

    const targetUrl = match[0];
    console.log("Extracted URL:", targetUrl);

    // Using the same reliable proxy for now
    const corsProxyUrl = 'https://api.allorigins.win/raw?url=';
    const proxiedUrl = corsProxyUrl + encodeURIComponent(targetUrl);

    loadingIndicator.style.display = 'block';
    extractButton.disabled = true;

    fetch(proxiedUrl)
      .then(response => {
        if (!response.ok) {
          let errorMsg = `Proxy fetch failed: ${response.status} ${response.statusText}`;
          if (response.status === 404) errorMsg += ". URL not found via proxy.";
          else if (response.status === 403) errorMsg += ". Access denied (proxy blocked?).";
          else if (response.status >= 500) errorMsg += ". Proxy server error.";
          throw new Error(errorMsg);
        }
        return response.text();
      })
      .then(html => {
        let doc;
        try {
            const parser = new DOMParser();
            doc = parser.parseFromString(html, 'text/html');
        } catch (parseError) {
            console.error("DOM Parsing Error:", parseError);
            throw new Error("Failed to parse the HTML content.");
        }

        let article = null;
        if (typeof Readability === 'undefined') {
            console.warn("Readability.js not loaded. Falling back.");
            // Don't display error here yet, let fallback try first
        } else {
            try {
                 const documentClone = doc.cloneNode(true);
                 let reader = new Readability(documentClone);
                 article = reader.parse();
            } catch (readabilityError) {
                console.error("Readability Error:", readabilityError);
                 // Don't display error here yet, let fallback try first
            }
        }

        let extractionSource = ''; // To track how text was extracted

        if (article && article.textContent && article.textContent.trim().length > 100) {
            extractedText.value = article.textContent.trim();
            extractionSource = 'Readability';
        } else {
            console.log("Readability failed/insufficient, attempting fallback...");
            const mainElement = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.post-content') || doc.querySelector('.entry-content') || doc.body;

            if (mainElement) {
                const scripts = mainElement.querySelectorAll('script, style, nav, header, footer, aside, .sidebar, .ads, [aria-hidden="true"], noscript, form, button, input'); // More elements to remove
                scripts.forEach(el => el.remove());
                extractedText.value = mainElement.textContent.trim().replace(/\s\s+/g, ' '); // Basic whitespace cleanup
            } else {
                 extractedText.value = doc.body ? doc.body.textContent.trim().replace(/\s\s+/g, ' ') : '';
            }

            if (extractedText.value.trim().length > 50) {
                extractionSource = 'basic fallback';
            } else {
                 // Both methods failed significantly
                 extractedText.value = ''; // Clear out any tiny remnants
            }
        }

        // Display results based on extraction outcome
        if (extractionSource) {
            displaySuccess(`Extracted using ${extractionSource}.`);
            enableCopyButton(); // Enable button and potentially open details
            detailsElement.open = true; // Automatically open details on successful extraction
        } else {
            if (typeof Readability === 'undefined'){
                 displayError("Extraction failed. Readability.js missing & fallback found no content.");
            } else {
                displayError("Extraction failed: Could not get meaningful content.");
            }
            copyButton.disabled = true;
            detailsElement.open = false; // Keep closed if failed
        }

      })
      .catch(error => {
        console.error("Error during fetch or extraction:", error);
        displayError(`Error: ${error.message}`);
        detailsElement.open = false; // Ensure details are closed on error
      })
      .finally(() => {
        loadingIndicator.style.display = 'none';
        extractButton.disabled = false;
      });
  }

  function copyTextToClipboard() {
    if (!extractedText.value) {
        displayError("Nothing to copy.");
        return;
    }

    // Ensure the details section is open before trying to copy (though it should be if button is enabled)
    if (!detailsElement.open) {
        detailsElement.open = true;
    }

    navigator.clipboard.writeText(extractedText.value)
      .then(() => {
        displaySuccess("Content copied to clipboard!");
        // Maybe briefly change button text?
        copyButton.textContent = 'Copied!';
        setTimeout(() => { copyButton.textContent = 'Copy Extracted Text'; }, 1500);
      })
      .catch(err => {
        console.error('Failed to copy text: ', err);
        try {
            // Need the textarea to be visible for execCommand
            detailsElement.open = true;
            extractedText.select();
            document.execCommand('copy');
            displaySuccess("Copied (using fallback)!");
        } catch (execErr) {
             displayError("Failed to copy automatically.");
        }
      });
  }

  function resetUI() {
    errorMessage.textContent = '';
    successMessage.textContent = '';
    loadingIndicator.style.display = 'none';
    extractButton.disabled = false;
    copyButton.disabled = true; // Start disabled
    copyButton.textContent = 'Copy Extracted Text'; // Reset button text
    // Don't clear text on reset, only on new extraction start (handleExtraction clears implicitly)
    detailsElement.open = false; // Close details section on reset
  }

  function displayError(message) {
    errorMessage.textContent = message;
    successMessage.textContent = '';
  }

  function displaySuccess(message) {
    successMessage.textContent = message;
    errorMessage.textContent = '';
  }

  function enableCopyButton() {
    if(extractedText.value.trim()){
        copyButton.disabled = false;
    } else {
        copyButton.disabled = true;
    }
  }

</script>

</body>
</html>