--- START OF FILE index.html ---
<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <title>Modern Article Extractor</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="dark light">

    <!-- Pico.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@latest/css/pico.min.css">

    <!-- Favicon Links -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/android-chrome-192x192.png">

    <!-- Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00aeff">

    <style>
      /* --- Pico Variable Overrides & Custom Vars --- */
      :root {
        --pico-color-amber-500: #ffa000;
        --pico-color-red-550: #d32f2f;
        --pico-color-red-600: #c62828;
        --pico-border-radius-pill: 50px;
      }

      /* --- General Body & Layout --- */
      body {
        font-family: var(--font-family);
        margin: 0;
        padding: var(--pico-spacing);
        line-height: 1.6;
        background-color: var(--pico-color-dark-background);
        color: var(--pico-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        overflow-x: hidden;
        justify-content: flex-start;
      }

      main.container {
        padding: calc(var(--pico-spacing) * 1.5);
        margin: calc(var(--pico-spacing) * 2) auto var(--pico-spacing) auto;
        max-width: 700px;
        width: 90%;
        transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
        transform: translateY(0);
      }

      main.container.state-initial {
        transform: translateY(25vh); /* Start lower down */
      }

      /* --- Content Reveal Animation --- */
      #copy-button-wrapper,
      #extracted-content-details,
      #status-messages {
        display: block;
        opacity: 0;
        max-height: 0;
        overflow: hidden;
        transform: translateY(15px);
        transition: opacity 0.5s ease-out 0.25s, max-height 0.5s ease-out 0.25s, transform 0.5s ease-out 0.25s;
      }

      main.container:not(.state-initial) #copy-button-wrapper,
      main.container:not(.state-initial) #extracted-content-details,
      main.container:not(.state-initial) #status-messages {
        opacity: 1;
        max-height: 1000px; /* Arbitrary large value */
        transform: translateY(0);
      }

      /* --- Floating Settings Button --- */
      #settings-button {
        position: fixed;
        top: var(--pico-spacing);
        right: var(--pico-spacing);
        z-index: 100;
        padding: calc(var(--pico-spacing) * 0.3);
        width: auto;
        height: auto;
        border-radius: 50%;
        line-height: 0; /* Align SVG better */
      }

      #settings-button svg {
        width: 1.1em;
        height: 1.1em;
        vertical-align: middle;
      }

      /* --- Settings & Save Preset Dialog Animation & Backdrop --- */
      dialog#settings-dialog,
      dialog#save-preset-dialog { /* Apply common styles to both dialogs */
        max-width: 500px;
        border-radius: var(--pico-border-radius);
        padding: 0; /* Padding is handled by article */
        opacity: 0;
        transform: scale(0.95) translateY(10px);
        transition: opacity 0.25s ease-out, transform 0.25s ease-out, display 0.25s allow-discrete; /* Animate display for accessibility */
        pointer-events: none; /* Prevent interaction when hidden */
        overflow: visible; /* Allow potential box-shadow */
        background: transparent; /* Let article define background */
        box-shadow: none; /* Let article define shadow */
        border: none; /* Let article define border */
      }

      dialog#settings-dialog::backdrop,
      dialog#save-preset-dialog::backdrop { /* Backdrop styles for both */
        background-color: rgba(26, 26, 26, 0); /* Start transparent */
        transition: background-color 0.3s ease-out;
      }

      /* Styles for when the dialog is open */
      dialog#settings-dialog[open],
      dialog#save-preset-dialog[open] {
        opacity: 1;
        transform: scale(1) translateY(0);
        pointer-events: auto; /* Allow interaction when open */
      }

      /* Styles for when the dialog is open - backdrop */
      dialog#settings-dialog[open]::backdrop,
      dialog#save-preset-dialog[open]::backdrop {
        background-color: rgba(26, 26, 26, 0.6); /* Darken background */
      }

      /* Ensure article inside dialog gets the styling */
      dialog#settings-dialog > article,
      dialog#save-preset-dialog > article {
        background-color: var(--pico-card-background-color);
        border: 1px solid var(--pico-card-border-color);
        box-shadow: var(--pico-card-box-shadow);
        border-radius: var(--pico-border-radius);
        margin: 0;
        padding: var(--pico-block-spacing-vertical) var(--pico-block-spacing-horizontal);
      }
      /* --- END Dialog Animation & Backdrop --- */

      /* --- Specific Dialog Content Styles --- */
      dialog#settings-dialog textarea {
        margin-bottom: var(--pico-spacing);
        min-height: 80px;
      }

      dialog#save-preset-dialog #preset-text-display { /* Style for prefix display */
          background-color: var(--pico-form-element-background-color);
          border: 1px solid var(--pico-form-element-border-color);
          border-radius: var(--pico-border-radius);
          padding: var(--pico-form-element-spacing-vertical) var(--pico-form-element-spacing-horizontal);
          font-family: var(--pico-font-monospace);
          font-size: 0.9em;
          max-height: 150px; /* Limit height and allow scroll */
          overflow-y: auto;
          margin-top: calc(var(--pico-spacing) * 0.5);
          margin-bottom: var(--pico-spacing);
          white-space: pre-wrap; /* Preserve line breaks */
          word-wrap: break-word; /* Prevent long unbroken strings from overflowing */
      }
      dialog#save-preset-dialog label {
        font-weight: var(--pico-font-weight-semibold);
      }
      dialog#save-preset-dialog input[type="text"] {
        margin-bottom: var(--pico-spacing);
      }
      dialog#save-preset-dialog small.char-count {
        font-size: 0.8em;
        color: var(--pico-secondary);
        display: block;
        text-align: right;
        margin-top: calc(var(--pico-spacing) * -0.75); /* Pull up closer to input */
        margin-bottom: var(--pico-spacing);
      }

      /* --- Preset Button Containers & Buttons --- */
      .prefix-buttons-container {
        margin-bottom: calc(var(--pico-spacing) * 1.5);
        display: flex;
        flex-wrap: wrap;
        gap: calc(var(--pico-spacing) * 0.5);
        align-items: center;
      }

      .prefix-buttons-container small,
      .custom-preset-buttons-container + small /* Target label dynamically added */
      {
        width: 100%;
        margin-bottom: calc(var(--pico-spacing) * 0.25);
        color: var(--pico-secondary);
        font-size: 0.85em;
      }

      .prefix-buttons-container button,
      .custom-preset-buttons-container button { /* Style all preset buttons */
          padding: calc(var(--pico-spacing) * 0.4) calc(var(--pico-spacing) * 0.8);
          font-size: 0.9em;
          margin: 0; /* Remove default margins */
      }

      .custom-preset-buttons-container { /* Container for added buttons */
          margin-top: calc(var(--pico-spacing) * 0.5); /* Space above custom buttons */
          display: flex;
          flex-wrap: wrap;
          gap: calc(var(--pico-spacing) * 0.5);
          align-items: center;
          border-top: 1px solid var(--pico-card-border-color); /* Separator line */
          padding-top: calc(var(--pico-spacing) * 0.75);
          margin-bottom: var(--pico-spacing); /* Space before footer */
      }

      .custom-preset-buttons-container:empty { /* Hide if empty visually and for spacing*/
          display: none;
          border-top: none;
          padding-top: 0;
          margin-top: 0;
          margin-bottom: 0;
      }

      /* Conditionally Visible "Add as Preset" Button */
      #add-preset-button {
          display: none; /* Hidden by default */
          margin-top: calc(var(--pico-spacing) * -0.5); /* Pull up slightly */
          margin-bottom: var(--pico-spacing);
          width: 100%;
          font-size: 0.9em;
          padding: calc(var(--pico-spacing) * 0.5) var(--pico-spacing);
      }
      #add-preset-button.visible {
          display: block; /* Show when needed */
      }

      /* --- Dialog Footer & Header --- */
      dialog footer {
        text-align: right;
        margin-top: var(--pico-block-spacing-vertical); /* Add space above footer */
      }

      dialog header > button[aria-label="Close"] {
        margin-left: auto; /* Push close button to the right */
        margin-bottom: 0;
      }

      /* --- Main Page Elements --- */
      h1 {
        font-size: 1.75em;
        margin-bottom: var(--pico-block-spacing-vertical);
        text-align: center;
      }

      #input-group {
        display: flex;
        align-items: center;
        background-color: var(--pico-form-element-background-color);
        border-radius: var(--pico-border-radius-pill); /* Rounded pill shape */
        border: var(--pico-border-width) solid var(--pico-form-element-border-color);
        padding: 0;
        overflow: hidden; /* Clip button corners */
        margin-bottom: var(--pico-block-spacing-vertical);
      }

      #input-group:focus-within {
        border-color: var(--pico-primary);
        box-shadow: 0 0 0 var(--pico-outline-width) var(--pico-primary-focus);
      }

      #url-input {
        flex-grow: 1;
        border: none;
        background-color: transparent;
        padding: var(--pico-form-element-spacing-vertical) var(--pico-form-element-spacing-horizontal);
        padding-right: calc(var(--pico-form-element-spacing-horizontal) / 2);
        font-size: 1em;
        color: var(--pico-form-element-color);
        outline: none !important; /* Force remove outline */
        box-shadow: none !important; /* Force remove shadow */
        margin: 0;
        min-width: 0; /* Prevent shrinking too much */
      }

      #url-input::placeholder {
        color: var(--pico-secondary);
      }

      /* Extract/Reset Button */
      #extract-button {
        flex-shrink: 0;
        border: none;
        background-color: var(--pico-primary);
        color: var(--pico-primary-inverse);
        margin: 4px; /* Space inside the input group */
        border-radius: 50%; /* Make it circular */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.4em;
        font-weight: bold;
        line-height: 1; /* Keep tight */
        width: 2.4em;  /* Fixed size */
        height: 2.4em; /* Fixed size */
        padding: 0;
        transition: background-color var(--pico-transition), transform 0.2s ease-in-out, color 0.1s ease;
        position: relative; /* For loader positioning */
        overflow: hidden; /* Clip loader */
        transform: rotate(0deg); /* Initial state for rotation */
      }
      #extract-button:hover:not([aria-busy=true]):not(.reset-mode) {
        background-color: var(--pico-primary-hover);
      }
      #extract-button:active:not([aria-busy=true]):not(.reset-mode) {
        transform: scale(0.95); /* Click feedback */
      }
      #extract-button[aria-busy=true] {
        background-color: var(--pico-secondary);
        cursor: default;
        color: transparent; /* Hide icon/text when busy */
      }
      #extract-button[aria-busy=true]::before { /* Pico loader */
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        margin: 0 !important; /* Override Pico's margin */
      }
      #extract-button.reset-mode {
        background-color: var(--pico-color-red-550);
        color: #fff;
        transform: rotate(180deg); /* Rotate for reset */
      }
      #extract-button.reset-mode:hover:not([aria-busy=true]) {
        background-color: var(--pico-color-red-600);
      }
      #extract-button.reset-mode:active:not([aria-busy=true]) {
        transform: rotate(180deg) scale(0.95); /* Click feedback in reset mode */
      }

      /* Copy/Share Buttons */
      #copy-button-wrapper {
        margin-bottom: calc(var(--pico-spacing) / 2);
        display: flex;
        justify-content: center;
        gap: var(--pico-spacing);
        flex-wrap: wrap;
      }

      #copy-button,
      #share-button {
        background-color: var(--pico-card-background-color); /* Use card bg for contrast */
        color: var(--pico-contrast-foreground);
        border: 1px solid var(--pico-contrast-border);
        padding: calc(var(--pico-spacing) * 0.6) calc(var(--pico-spacing) * 1.0);
        border-radius: var(--pico-border-radius);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: calc(var(--pico-spacing) * 0.5);
        transition: background-color var(--pico-transition), border-color var(--pico-transition), transform 0.1s ease, box-shadow var(--pico-transition), opacity 0.2s ease;
        cursor: pointer;
        font-weight: var(--pico-font-weight-medium);
        width: auto; /* Let content define width */
        display: none; /* Hide initially, shown by JS */
      }
      #copy-button.enabled,
      #share-button.enabled {
          display: inline-flex; /* Show if enabled by JS */
      }
      #copy-button .icon-wrapper,
      #share-button .icon-wrapper {
        display: inline-flex;
        align-items: center;
        line-height: 0; /* Help vertical alignment */
      }
      #copy-button svg,
      #share-button svg {
        width: 1.1em;
        height: 1.1em;
        fill: currentColor;
      }
      #copy-button:not(:disabled):hover,
      #share-button:not(:disabled):hover {
        background-color: var(--pico-contrast-hover-background);
        border-color: var(--pico-contrast-hover-border);
        transform: translateY(-1px); /* Slight lift effect */
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
      }
      #copy-button:not(:disabled):active,
      #share-button:not(:disabled):active {
        transform: translateY(0px); /* Press down effect */
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      #copy-button:disabled,
      #share-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
        /* Keep base styles when disabled */
        background-color: var(--pico-card-background-color);
        color: var(--pico-contrast-foreground);
        border-color: var(--pico-contrast-border);
      }
      #copy-button.secondary { /* Style for 'Copied!' state */
        background-color: var(--pico-secondary-background);
        border-color: var(--pico-secondary-border);
        color: var(--pico-secondary-foreground);
      }

      /* Extracted Text Area */
      #extracted-text {
        font-family: var(--pico-font-monospace);
        height: 250px; /* Default height */
        resize: vertical; /* Allow user resizing */
        margin-bottom: 0; /* Remove default bottom margin */
      }

      /* Details/Summary for Extracted Text */
      details summary {
        font-weight: var(--pico-font-weight-semibold);
        margin-top: var(--pico-spacing);
      }
      details > div {
        padding-top: var(--pico-form-element-spacing-vertical); /* Space above textarea */
      }

      /* Status Messages */
      #status-messages {
        margin-top: var(--pico-block-spacing-vertical);
        min-height: 1.5em; /* Reserve space */
        text-align: center;
        font-weight: var(--pico-font-weight-medium);
        font-size: 0.9em;
      }
      #error-message { color: var(--pico-color-red-500); }
      #success-message { color: var(--pico-color-green-500); }
      #retry-message { color: var(--pico-color-amber-500); }

      /* Error messages inside dialogs */
      .dialog-error-message {
          color: var(--pico-color-red-500);
          font-size: 0.9em;
          margin-top: calc(var(--pico-spacing) * -0.75); /* Pull up closer to input */
          margin-bottom: var(--pico-spacing);
          min-height: 1.2em; /* Reserve space */
      }

      /* --- Responsive Adjustments --- */
      @media (min-width: 768px) {
        h1 { font-size: 2em; }
        #extracted-text { height: 300px; }
      }
      @media (min-width: 992px) {
        #extracted-text { height: 350px; }
      }
    </style>
</head>
<body data-theme="dark">

<main class="container state-initial">
    <h1>Article Extractor</h1>
    <div id="input-group">
        <input type="text" id="url-input" name="url-input" placeholder="Paste URL or text here...">
        <button id="extract-button" title="Extract Text" aria-label="Extract Text"></button>
    </div>
    <div id="copy-button-wrapper">
       <button id="copy-button" disabled>
            <span class="icon-wrapper"></span>
            <span class="text-wrapper">Copy</span>
       </button>
       <button id="share-button" disabled>
            <span class="icon-wrapper"></span>
           <span class="text-wrapper">Share</span>
       </button>
    </div>
    <details id="extracted-content-details">
        <summary>View Extracted Text</summary>
        <div>
            <textarea id="extracted-text" name="extracted-text" readonly placeholder="Extracted text will appear here..."></textarea>
        </div>
    </details>
    <div id="status-messages">
        <div id="retry-message"></div>
        <div id="error-message"></div>
        <div id="success-message"></div>
    </div>
</main>

<button id="settings-button" class="outline contrast" title="Settings" aria-label="Settings">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
</button>

<dialog id="settings-dialog">
    <article>
        <header>
            <button aria-label="Close" rel="prev" id="settings-close-button"></button>
            <strong>Settings</strong>
        </header>
        <form id="settings-form">
             <label for="prefix-textarea">
                Prefix Text (prepended to extracted content):
                <textarea id="prefix-textarea" name="prefix" rows="4" placeholder="Enter text to prepend..."></textarea>
            </label>
            <!-- Add Preset button (conditionally visible) -->
            <button type="button" id="add-preset-button" class="outline contrast">Add as Preset</button>

            <div class="prefix-buttons-container">
                <small>Quick Presets:</small>
                <button type="button" id="prefix-summarise-btn" class="outline secondary">Summarise</button>
                <button type="button" id="prefix-factcheck-btn" class="outline secondary">Fact-check</button>
                <button type="button" id="prefix-formatting-btn" class="outline secondary">Formatting</button>
            </div>
            <!-- Container for dynamically added custom presets -->
            <div class="custom-preset-buttons-container" id="custom-preset-buttons-container">
                <!-- Custom presets will be added here by JS -->
                <!-- Label "Your Presets:" is added dynamically by JS if needed -->
            </div>
            <footer>
                <button type="submit" id="settings-save-button">Save Prefix</button>
            </footer>
        </form>
    </article>
</dialog>

<!-- New Dialog for Saving Custom Preset -->
<dialog id="save-preset-dialog">
    <article>
        <header>
            <button aria-label="Close" rel="prev" id="cancel-save-preset-button"></button>
            <strong>Save Custom Preset</strong>
        </header>
        <form id="save-preset-form">
            <label for="preset-title-input">
                Preset Title (max 15 chars):
                <input type="text" id="preset-title-input" name="preset-title" maxlength="15" required placeholder="e.g., My Summary">
            </label>
             <small id="preset-title-char-count" class="char-count">0 / 15</small>
            <label for="preset-text-display">
                Preset Text:
                <div id="preset-text-display" readonly aria-live="polite"></div> <!-- Display prefix here -->
            </label>
            <div id="save-preset-error-message" class="dialog-error-message"></div> <!-- Error message area -->
            <footer>
                <button type="button" id="cancel-save-preset-button-footer" class="secondary outline">Cancel</button>
                <button type="submit" id="confirm-save-preset-button">Save Preset</button>
            </footer>
        </form>
    </article>
</dialog>


<!-- ***** INCLUDE Readability.js SCRIPT HERE ***** -->
<script src="readability.js"></script>

<script>
    // --- Constants ---
    const PROXY_URL = 'https://api.allorigins.win/raw?url=';
    const MAX_RETRIES = 3;
    const RETRY_DELAY_MS = 1500;
    const DEBOUNCE_DELAY_MS = 300; // Debounce for input checks (e.g., prefix)
    const EXTRACTION_DEBOUNCE_DELAY_MS = 500; // Debounce for extraction trigger
    const DEFAULT_TEXT_PREFIX = "Summarise the key points from the following article:\n\n";
    const PREFIX_STORAGE_KEY = 'articleExtractorPrefix';
    const CUSTOM_PRESETS_STORAGE_KEY = 'articleExtractorCustomPresets'; // New key for custom presets
    const MAX_PRESET_TITLE_LENGTH = 15;
    const PRESET_SUMMARISE = "Summarise the key points from the following article:\n\n";
    const PRESET_FACTCHECK = "I want you to fact check this article in full. Leave no stone unturned. To do so, first, look at the text of the article and parse out each individual fact — after this, you should have a list of facts. Then, for each fact, do comprehensive research to determine whether it is true, false, or unclear. Aim for at least three independent, high quality and trustworthy sources for each fact.\n Then, once you've done this for *every* fact, return a table with each fact and its corresponding results (including sources for each check).:\n\n";
    const PRESET_FORMATTING = "Fix the punctuation and formatting of the following text:\n\n";

    // --- SVG Icons ---
    const ICON_COPY_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-copy"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>`;
    const ICON_CHECK_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
    const ICON_RESET_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
    const ICON_SHARE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>`;

    // --- State Variables ---
    let currentTextPrefix = DEFAULT_TEXT_PREFIX;
    let customPresets = []; // Holds { title: '...', text: '...' } objects
    let isInResetMode = false;
    const isShareSupported = typeof navigator.share === 'function';
    let prefixCheckDebounceTimer; // Debounce timer for prefix input check
    let extractionDebounceTimer; // Extraction debounce timer

    // --- Element References ---
    const mainContainer = document.querySelector('main.container');
    const urlInput = document.getElementById('url-input');
    const extractButton = document.getElementById('extract-button');
    const extractedText = document.getElementById('extracted-text');
    const copyButton = document.getElementById('copy-button');
    const copyButtonIconWrapper = copyButton.querySelector('.icon-wrapper');
    const copyButtonTextWrapper = copyButton.querySelector('.text-wrapper');
    const shareButton = document.getElementById('share-button');
    const shareButtonIconWrapper = shareButton?.querySelector('.icon-wrapper');
    const shareButtonTextWrapper = shareButton?.querySelector('.text-wrapper');
    const errorMessage = document.getElementById('error-message');
    const successMessage = document.getElementById('success-message');
    const retryMessage = document.getElementById('retry-message');
    const detailsElement = document.getElementById('extracted-content-details');
    const copyButtonWrapper = document.getElementById('copy-button-wrapper');
    // Settings Dialog
    const settingsButton = document.getElementById('settings-button');
    const settingsDialog = document.getElementById('settings-dialog');
    const settingsCloseButton = document.getElementById('settings-close-button');
    const settingsForm = document.getElementById('settings-form');
    const prefixTextarea = document.getElementById('prefix-textarea');
    const settingsSaveButton = document.getElementById('settings-save-button');
    const prefixSummariseBtn = document.getElementById('prefix-summarise-btn');
    const prefixFactcheckBtn = document.getElementById('prefix-factcheck-btn');
    const prefixFormattingBtn = document.getElementById('prefix-formatting-btn');
    const addPresetButton = document.getElementById('add-preset-button');
    const customPresetButtonsContainer = document.getElementById('custom-preset-buttons-container');
    // Save Preset Dialog
    const savePresetDialog = document.getElementById('save-preset-dialog');
    const savePresetForm = document.getElementById('save-preset-form');
    const presetTitleInput = document.getElementById('preset-title-input');
    const presetTitleCharCount = document.getElementById('preset-title-char-count');
    const presetTextDisplay = document.getElementById('preset-text-display');
    const confirmSavePresetButton = document.getElementById('confirm-save-preset-button');
    const cancelSavePresetButton = document.getElementById('cancel-save-preset-button'); // Header close
    const cancelSavePresetButtonFooter = document.getElementById('cancel-save-preset-button-footer'); // Footer cancel
    const savePresetErrorMessage = document.getElementById('save-preset-error-message');

    // --- Load Prefixes (Current and Custom) ---
    function loadPrefix() {
        try {
            const storedPrefix = localStorage.getItem(PREFIX_STORAGE_KEY);
            if (storedPrefix !== null) {
                currentTextPrefix = storedPrefix;
                console.log("Loaded prefix from localStorage");
            } else {
                currentTextPrefix = DEFAULT_TEXT_PREFIX;
            }
        } catch (e) {
            console.error("Could not access localStorage for prefix. Using default.", e);
            currentTextPrefix = DEFAULT_TEXT_PREFIX;
        }
        if (prefixTextarea) prefixTextarea.value = currentTextPrefix;
    }

    function loadCustomPresets() {
        try {
            const storedCustom = localStorage.getItem(CUSTOM_PRESETS_STORAGE_KEY);
            if (storedCustom) {
                customPresets = JSON.parse(storedCustom);
                console.log("Loaded custom presets from localStorage:", customPresets);
            } else {
                customPresets = [];
            }
        } catch (e) {
            console.error("Could not load/parse custom presets from localStorage.", e);
            customPresets = [];
            // Optionally clear bad data if parsing fails
            // localStorage.removeItem(CUSTOM_PRESETS_STORAGE_KEY);
        }
        renderCustomPresetButtons();
    }

    function saveCustomPresets() {
        try {
            localStorage.setItem(CUSTOM_PRESETS_STORAGE_KEY, JSON.stringify(customPresets));
            console.log("Saved custom presets to localStorage:", customPresets);
        } catch (e) {
            console.error("Could not save custom presets to localStorage.", e);
            displayError("Failed to save custom presets."); // Inform user
        }
    }

    // --- Render Custom Preset Buttons ---
    function renderCustomPresetButtons() {
        if (!customPresetButtonsContainer) return;
        const existingLabel = customPresetButtonsContainer.previousElementSibling;
        customPresetButtonsContainer.innerHTML = ''; // Clear existing custom buttons

        // Manage the "Your Presets:" label visibility
        if (customPresets.length > 0) {
             // Check if the PREVIOUS sibling is the label we might add
             if (!existingLabel || !existingLabel.matches('small') || existingLabel.textContent !== 'Your Presets:') {
                 // If no label, or wrong label exists, remove old and add new one
                 if(existingLabel && existingLabel.matches('small')) existingLabel.remove();
                 const small = document.createElement('small');
                 small.textContent = 'Your Presets:';
                 // Insert before the container (which might be hidden if empty before)
                 customPresetButtonsContainer.insertAdjacentElement('beforebegin', small);
             }
        } else {
            // Remove label if no custom presets exist
            if (existingLabel && existingLabel.matches('small') && existingLabel.textContent === 'Your Presets:') {
                existingLabel.remove();
            }
        }

        // Add buttons for each custom preset
        customPresets.forEach(preset => {
            const button = document.createElement('button');
            button.type = 'button';
            button.classList.add('outline', 'secondary', 'custom-preset-btn');
            button.textContent = preset.title;
            button.title = `Apply preset: "${preset.title}"`; // Tooltip for full text preview might be too much
            button.addEventListener('click', () => {
                setPrefixFromPreset(preset.text);
            });
            customPresetButtonsContainer.appendChild(button);
        });
    }

    // --- Initial Setup ---
    function setInitialButtonState() {
        extractButton.innerHTML = '→'; // Right arrow
        extractButton.title = 'Extract Text';
        extractButton.setAttribute('aria-label', 'Extract Text');
        extractButton.classList.remove('reset-mode');
        isInResetMode = false;
    }
    function setInitialCopyIcon() { if (copyButtonIconWrapper) copyButtonIconWrapper.innerHTML = ICON_COPY_SVG; }
    function setInitialShareIcon() { if (isShareSupported && shareButtonIconWrapper) shareButtonIconWrapper.innerHTML = ICON_SHARE_SVG; }

    loadPrefix();
    loadCustomPresets(); // Load custom presets after defaults
    setInitialCopyIcon();
    setInitialShareIcon();
    setInitialButtonState();
    copyButton.classList.add('enabled'); // Enable copy button structure (disabled state handled later)
    if (isShareSupported && shareButton) {
        shareButton.classList.add('enabled'); // Enable share button structure
    }

    // --- Settings Dialog Logic ---
    function openSettings() {
        if (!settingsDialog) return;
        prefixTextarea.value = currentTextPrefix;
        checkPrefixForCustomSave(); // Check initial state when opening
        renderCustomPresetButtons(); // Ensure buttons are up-to-date when opening
        settingsDialog.showModal();
    }
    function closeSettings() { if (!settingsDialog) return; settingsDialog.close(); }
    function handleSettingsBackdropClick(event) { if (event.target === settingsDialog) { closeSettings(); } }

    // Saves the currently displayed prefix in the textarea
    function saveSettings(event) {
        event.preventDefault();
        if (!prefixTextarea) return;
        const newPrefix = prefixTextarea.value;
        const oldPrefix = currentTextPrefix; // Keep track in case we need to update output

        currentTextPrefix = newPrefix; // Update state

        try {
            localStorage.setItem(PREFIX_STORAGE_KEY, newPrefix);
            console.log("Saved current prefix to localStorage");
            displaySuccess("Prefix saved!");
            setTimeout(clearMessages, 2000); // Clear success message after 2s

            // Optionally update the already extracted text if it used the old prefix
            const currentOutput = extractedText.value;
            // Check if there is output, it started with the *exact* old prefix, and there's text after it
            if (currentOutput && currentOutput.startsWith(oldPrefix) && currentOutput.length > oldPrefix.length) {
                const rawTextPart = currentOutput.substring(oldPrefix.length);
                // Add new prefix (ensure proper spacing if prefix exists)
                const formattedNewPrefix = newPrefix.trimEnd() + (newPrefix ? "\n\n" : "");
                extractedText.value = formattedNewPrefix + rawTextPart;
                console.log("Dynamically updated displayed text with new prefix.");
            }
        } catch (e) {
            console.error("Could not save prefix to localStorage.", e);
            displayError("Could not save prefix.");
            currentTextPrefix = oldPrefix; // Revert state on error
        }
        closeSettings();
    }

    // Sets the prefix textarea value from a preset button click
    function setPrefixFromPreset(presetValue) {
        if (prefixTextarea) {
            prefixTextarea.value = presetValue;
            checkPrefixForCustomSave(); // Update "Add as Preset" button visibility
        }
    }

    // --- Custom Preset Saving Logic ---

    // Checks if a given text (trimmed) matches any existing preset (trimmed)
    function isExistingPreset(text) {
        if (!text) return true; // Empty/null text is invalid
        const trimmedText = text.trim();
        if (!trimmedText) return true; // Treat blank/whitespace-only as existing/invalid

        const defaultPresets = [PRESET_SUMMARISE, PRESET_FACTCHECK, PRESET_FORMATTING];
        // Compare trimmed input against trimmed default presets
        if (defaultPresets.some(preset => preset.trim() === trimmedText)) {
            return true;
        }
        // Compare trimmed input against trimmed custom presets
        return customPresets.some(preset => preset.text.trim() === trimmedText);
    }

    // Shows/hides the "Add as Preset" button based on textarea content
    function checkPrefixForCustomSave() {
        if (!prefixTextarea || !addPresetButton) return;
        const currentPrefixText = prefixTextarea.value; // Get the raw value first
        const trimmedPrefixText = currentPrefixText.trim(); // Trim it for checking

        // Show button if trimmed text is not empty AND it doesn't match any existing trimmed preset
        if (trimmedPrefixText && !isExistingPreset(trimmedPrefixText)) {
            addPresetButton.classList.add('visible');
        } else {
            addPresetButton.classList.remove('visible');
        }
    }

    // Triggered when "Add as Preset" button is clicked
    function handleAddPresetClick() {
        const prefixTextToDisplay = prefixTextarea.value; // Get raw value for display
        const trimmedCheckText = prefixTextToDisplay.trim(); // Trim for final check

        // Safeguard check (should be prevented by button visibility)
        if (!trimmedCheckText || isExistingPreset(trimmedCheckText)) {
            console.warn("Add Preset clicked, but text is empty or already exists (trimmed comparison).");
            checkPrefixForCustomSave(); // Ensure button state is correct
            return;
        }

        // Populate and open the save dialog
        presetTextDisplay.textContent = prefixTextToDisplay; // Show raw text
        presetTitleInput.value = ''; // Clear title input
        savePresetErrorMessage.textContent = ''; // Clear any old errors
        updateCharCount(); // Reset char count display
        savePresetDialog.showModal();
        presetTitleInput.focus(); // Focus title input for convenience
    }

    function closeSavePresetDialog() {
        if(savePresetDialog) savePresetDialog.close();
    }
    function handleSavePresetDialogBackdropClick(event) {
        if (event.target === savePresetDialog) {
            closeSavePresetDialog();
        }
    }

    // Handles the final confirmation of saving a new preset
    function handleConfirmSavePreset(event) {
        event.preventDefault(); // Prevent form submission reloading page
        const presetTitle = presetTitleInput.value.trim();
        // Get text from display div AND TRIM IT for saving and final check
        const prefixTextToSave = presetTextDisplay.textContent.trim();

        savePresetErrorMessage.textContent = ''; // Clear previous errors

        // --- Validation ---
        if (!presetTitle) {
            savePresetErrorMessage.textContent = 'Preset title cannot be empty.';
            presetTitleInput.focus();
            return;
        }
        if (presetTitle.length > MAX_PRESET_TITLE_LENGTH) {
            savePresetErrorMessage.textContent = `Title exceeds ${MAX_PRESET_TITLE_LENGTH} characters.`;
            presetTitleInput.focus();
            return;
        }
        // Check for duplicate titles (case-insensitive)
        if (customPresets.some(p => p.title.toLowerCase() === presetTitle.toLowerCase())) {
            savePresetErrorMessage.textContent = 'A preset with this title already exists.';
            presetTitleInput.focus();
            return;
        }
        // Final check for duplicate text content using the trimmed value
         if (isExistingPreset(prefixTextToSave)) { // Check the trimmed version again
            savePresetErrorMessage.textContent = 'This prefix content is already saved.';
             console.warn("Save confirmation failed: Trimmed prefix content already exists.");
            return;
        }
        // --- End Validation ---

        // Add the TRIMMED text to custom presets array
        customPresets.push({ title: presetTitle, text: prefixTextToSave });
        saveCustomPresets(); // Save updated array to localStorage
        renderCustomPresetButtons(); // Update buttons in settings dialog
        closeSavePresetDialog(); // Close the naming dialog
        checkPrefixForCustomSave(); // Hide the 'Add as preset' button again as the current text is now saved
    }

    // Updates the character count display for the preset title input
    function updateCharCount() {
         if(presetTitleInput && presetTitleCharCount) {
            const count = presetTitleInput.value.length;
            presetTitleCharCount.textContent = `${count} / ${MAX_PRESET_TITLE_LENGTH}`;
         }
    }


    // --- NAMED EVENT HANDLERS for Debouncing/Clarity ---
    function triggerExtractionDebounced() {
        if (extractButton.getAttribute('aria-busy') === 'true' || isInResetMode) return;
        clearTimeout(extractionDebounceTimer);
        extractionDebounceTimer = setTimeout(handleExtraction, EXTRACTION_DEBOUNCE_DELAY_MS);
    }
    function triggerReset() { resetUI(); }
    // Debounced handler for prefix textarea input
    function handlePrefixInputDebounced() {
        clearTimeout(prefixCheckDebounceTimer);
        prefixCheckDebounceTimer = setTimeout(checkPrefixForCustomSave, DEBOUNCE_DELAY_MS);
    }


    // --- Share Handler ---
    async function handleShare() {
        if (!isShareSupported || shareButton.disabled) return;
        const textToShare = extractedText.value;
        if (!textToShare || !textToShare.trim()) {
            displayError("Nothing to share.");
            return;
        }
        try {
            await navigator.share({ text: textToShare });
            console.log('Content shared successfully');
            // No success message needed, system dialog handles feedback
        } catch (err) {
            if (err.name === 'AbortError') {
                console.log('Share dialog dismissed by user.');
            } else {
                console.error('Error sharing:', err);
                displayError(`Share failed: ${err.message}`);
            }
        }
    }

    // --- Event Listeners ---
    // Settings Dialog
    settingsButton?.addEventListener('click', openSettings);
    settingsCloseButton?.addEventListener('click', closeSettings);
    settingsDialog?.addEventListener('click', handleSettingsBackdropClick);
    settingsForm?.addEventListener('submit', saveSettings); // Handles saving the *current* prefix

    // Standard Preset Buttons
    prefixSummariseBtn?.addEventListener('click', () => setPrefixFromPreset(PRESET_SUMMARISE));
    prefixFactcheckBtn?.addEventListener('click', () => setPrefixFromPreset(PRESET_FACTCHECK));
    prefixFormattingBtn?.addEventListener('click', () => setPrefixFromPreset(PRESET_FORMATTING));

    // Custom Preset Handling
    prefixTextarea?.addEventListener('input', handlePrefixInputDebounced); // Check on input to show/hide "Add" button
    addPresetButton?.addEventListener('click', handleAddPresetClick); // Open the save dialog

    // Save Preset Dialog Listeners
    savePresetDialog?.addEventListener('click', handleSavePresetDialogBackdropClick);
    savePresetForm?.addEventListener('submit', handleConfirmSavePreset); // Main save action
    confirmSavePresetButton?.addEventListener('click', handleConfirmSavePreset); // Click fallback for save
    cancelSavePresetButton?.addEventListener('click', closeSavePresetDialog); // Header close button
    cancelSavePresetButtonFooter?.addEventListener('click', closeSavePresetDialog); // Footer cancel button
    presetTitleInput?.addEventListener('input', updateCharCount); // Update char count on input

    // Main Actions
    extractButton.addEventListener('click', () => { // Combined click handler
        if (isInResetMode) {
            triggerReset();
        } else {
            triggerExtractionDebounced();
        }
    });
    urlInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault(); // Prevent form submission if wrapped in form
            if (extractButton.getAttribute('aria-busy') === 'true' || isInResetMode) return;
            triggerExtractionDebounced();
        }
    });
    copyButton.addEventListener('click', copyTextToClipboard);
    if (isShareSupported && shareButton) {
        shareButton.addEventListener('click', handleShare);
    }

    // --- Core Extraction Logic ---
    function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    async function fetchWithRetries(url, options, retries = MAX_RETRIES) {
        for (let i = 0; i <= retries; i++) {
            try {
                if (i > 0) {
                    displayRetryMessage(`Attempt ${i+1} of ${retries+1}...`);
                    await delay(RETRY_DELAY_MS * i); // Exponential backoff could be added
                }
                const response = await fetch(url, options);
                if (!response.ok) {
                    // Retry on server errors (5xx)
                    if (response.status >= 500 && response.status < 600 && i < retries) {
                        console.warn(`Attempt ${i+1} failed with status ${response.status}. Retrying...`);
                        continue; // Go to next iteration
                    }
                    // Throw for client errors (4xx) or final server error
                    throw new Error(`Proxy fetch failed: ${response.status} ${response.statusText}`);
                }
                clearRetryMessage(); // Clear retry message on success
                return response; // Success
            } catch (error) {
                console.error(`Attempt ${i+1} caught error:`, error);
                if (i === retries) { // If this was the last retry
                    clearRetryMessage(); // Clear any lingering retry message
                    throw error; // Re-throw the final error
                }
                // Otherwise, the loop will continue (or delay and retry)
            }
        }
        // Should not be reachable if retries >= 0, but acts as a fallback
        clearRetryMessage();
        throw new Error("Fetch failed after all retries.");
    }

    async function handleExtraction() {
        clearMessages();
        updateActionButtonsState(''); // Disable buttons initially
        const inputText = urlInput.value.trim();
        if (!inputText) {
            displayError("Please enter a URL or text containing one.");
            return;
        }

        // Basic URL regex (consider a more robust library if needed)
        const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
        const match = inputText.match(urlRegex);
        if (!match) {
            displayError("No valid URL found in the input.");
            return;
        }
        const targetUrl = match[0];
        console.log("Extracted URL:", targetUrl);

        const proxiedUrl = PROXY_URL + encodeURIComponent(targetUrl);
        setLoadingState(true); // Show loading indicator

        try {
            const response = await fetchWithRetries(proxiedUrl);
            const html = await response.text();

            // Parse HTML
            let doc;
            try {
                const parser = new DOMParser();
                doc = parser.parseFromString(html, 'text/html');
            } catch (parseError) {
                console.error("DOM Parsing Error:", parseError);
                throw new Error("Failed to parse the HTML content.");
            }

            // --- Readability Extraction ---
            let article = null;
            if (typeof Readability === 'undefined') {
                console.warn("Readability.js not loaded. Extraction quality may be reduced.");
            } else {
                try {
                    // Clone the document as Readability modifies it
                    const documentClone = doc.cloneNode(true);
                    // Pass the cloned document to Readability
                    let reader = new Readability(documentClone);
                    article = reader.parse();
                } catch (readabilityError) {
                    console.error("Readability Error:", readabilityError);
                    // Don't throw, allow fallback to continue
                }
            }

            let extractionSource = '';
            let rawExtractedText = '';

            // Use Readability result if it's good enough
            if (article && article.textContent && article.textContent.trim().length > 100) { // Threshold for meaningful content
                const title = article.title?.trim();
                const bodyText = article.textContent.trim(); // Readability provides cleaned textContent
                rawExtractedText = title ? `${title}\n\n${bodyText}` : bodyText;
                extractionSource = 'Readability';
            }
            // --- Fallback Extraction (if Readability fails or content is short) ---
            else {
                 if (!article && typeof Readability !== 'undefined') console.log("Readability failed or returned insufficient content, attempting fallback...");
                 else if (typeof Readability === 'undefined') console.log("Readability not loaded, attempting fallback...");
                 else console.log("Readability content insufficient, attempting fallback...");

                // Simple fallback: Find main content areas, remove scripts/styles, get text
                const mainElement = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.post-content') || doc.querySelector('.entry-content') || doc.body;

                if (mainElement) {
                    // Clone to avoid modifying the original parsed doc if needed elsewhere
                    const mainClone = mainElement.cloneNode(true);
                    // Remove common noise elements from the clone
                    const noiseSelectors = 'script, style, nav, header, footer, aside, .sidebar, .ad, .ads, [aria-hidden="true"], noscript, form, button, input, figure figcaption, .share-buttons, .comments-area, #comments';
                    mainClone.querySelectorAll(noiseSelectors).forEach(el => el.remove());
                    // Basic text extraction and cleanup
                    rawExtractedText = mainClone.textContent
                        .replace(/[\t\r\n]+/g, '\n') // Consolidate whitespace lines
                        .replace(/\n\s*\n/g, '\n\n') // Ensure double newlines for paragraphs
                        .replace(/ {2,}/g, ' ')    // Consolidate multiple spaces
                        .trim();
                } else {
                    // Absolute fallback: body text
                    rawExtractedText = doc.body ? doc.body.textContent.trim().replace(/\s\s+/g, ' ') : '';
                }

                // Decide if fallback was successful
                if (rawExtractedText.length > 50) { // Lower threshold for fallback
                     extractionSource = typeof Readability !== 'undefined' ? 'Basic Fallback (Readability failed)' : 'Basic Fallback';
                } else {
                    rawExtractedText = ''; // Discard if too short
                }
            }

            // --- Display Result or Error ---
            if (extractionSource) {
                const formattedPrefix = currentTextPrefix.trimEnd() + (currentTextPrefix ? "\n\n" : "");
                extractedText.value = formattedPrefix + rawExtractedText;
                displaySuccess(`Extracted using ${extractionSource}.`);
                updateActionButtonsState(rawExtractedText); // Enable buttons based on content
                mainContainer.classList.remove('state-initial'); // Animate container up
                detailsElement.open = true; // Show extracted text
                setResetMode(true); // Switch button to reset mode
            } else {
                // If both Readability and fallback failed
                extractedText.value = '';
                let finalError = "Extraction failed: Could not get meaningful content.";
                if (typeof Readability === 'undefined'){
                    finalError = "Extraction failed: Readability script missing & fallback failed.";
                }
                displayError(finalError);
                // Don't change main container position if it was already up
                if (!mainContainer.classList.contains('state-initial')) {
                   // Optional: could slide it down again, but might be jarring.
                   // mainContainer.classList.add('state-initial');
                }
                setResetMode(false); // Ensure button is in extract mode
                updateActionButtonsState(''); // Keep buttons disabled
                detailsElement.open = false;
            }
        } catch (error) {
            // Handle fetch errors or parsing errors
            console.error("Error during fetch or extraction:", error);
            extractedText.value = '';
            displayError(`Error: ${error.message}`);
            if (!mainContainer.classList.contains('state-initial')) {
               // mainContainer.classList.add('state-initial');
            }
            setResetMode(false);
            updateActionButtonsState('');
            detailsElement.open = false;
        } finally {
            setLoadingState(false); // Stop loading indicator
        }
    }

   function setLoadingState(isLoading) {
       // Using aria-busy for Pico's built-in loading indicator
       if (isLoading) {
           extractButton.setAttribute('aria-busy', 'true');
       } else {
           extractButton.removeAttribute('aria-busy');
       }
   }

    // Helper to manage the state of the extract/reset button
    function setResetMode(isReset) {
        isInResetMode = isReset;
        if (isReset) {
            extractButton.innerHTML = ICON_RESET_SVG;
            extractButton.classList.add('reset-mode');
            extractButton.title = 'Reset';
            extractButton.setAttribute('aria-label', 'Reset');
        } else {
            extractButton.innerHTML = '→'; // Back to arrow
            extractButton.classList.remove('reset-mode');
            extractButton.title = 'Extract Text';
            extractButton.setAttribute('aria-label', 'Extract Text');
        }
    }


    // --- Clipboard and UI Functions ---
    function copyTextToClipboard() {
        if (!extractedText.value || !extractedText.value.trim()) {
            displayError("Nothing to copy.");
            return;
        }
        // Ensure the text area is visible if details are closed
        if (!detailsElement.open) {
            detailsElement.open = true;
        }

        navigator.clipboard.writeText(extractedText.value)
            .then(() => {
                displaySuccess("Content copied to clipboard!");
                if (copyButtonIconWrapper) copyButtonIconWrapper.innerHTML = ICON_CHECK_SVG;
                if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copied!';
                copyButton.classList.add('secondary'); // Visual feedback
                // Reset button state after 2 seconds
                setTimeout(() => {
                    setInitialCopyIcon();
                    if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy';
                    copyButton.classList.remove('secondary');
                }, 2000);
            })
            .catch(err => {
                console.error('Failed to copy text using Clipboard API: ', err);
                // Fallback using document.execCommand (deprecated but common fallback)
                try {
                    if (!detailsElement.open) detailsElement.open = true; // Ensure visible
                    extractedText.select(); // Select the text
                    document.execCommand('copy'); // Attempt copy
                    displaySuccess("Copied (using fallback)!");
                    // Provide similar visual feedback for fallback
                    if (copyButtonIconWrapper) copyButtonIconWrapper.innerHTML = ICON_CHECK_SVG;
                    if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copied!';
                    copyButton.classList.add('secondary');
                    setTimeout(() => {
                         setInitialCopyIcon();
                         if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy';
                         copyButton.classList.remove('secondary');
                    }, 2000);
                } catch (execErr) {
                    console.error('Fallback copy method failed:', execErr);
                    displayError("Failed to copy automatically. Please copy manually.");
                }
            });
    }

    // Resets the entire UI to its initial state
    function resetUI() {
        clearMessages();
        setLoadingState(false); // Ensure loading is off
        urlInput.value = '';
        updateActionButtonsState(''); // Disable copy/share
        // Reset Copy button appearance
        setInitialCopyIcon();
        if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy';
        copyButton.classList.remove('secondary');
        // Reset Share button appearance
        setInitialShareIcon();
        if (isShareSupported && shareButtonTextWrapper) shareButtonTextWrapper.textContent = 'Share';
        // Hide and clear extracted text
        detailsElement.open = false;
        extractedText.value = '';
        // Reset main container position and button state
        mainContainer.classList.add('state-initial');
        setResetMode(false); // Switch back to extract mode
        urlInput.focus(); // Set focus back to input for convenience
    }

    // --- Status Message Helpers ---
    function displayError(message) { errorMessage.textContent = message; successMessage.textContent = ''; retryMessage.textContent = ''; }
    function displaySuccess(message) { successMessage.textContent = message; errorMessage.textContent = ''; retryMessage.textContent = ''; }
    function displayRetryMessage(message) { retryMessage.textContent = message; errorMessage.textContent = ''; successMessage.textContent = ''; }
    function clearRetryMessage() { retryMessage.textContent = ''; }
    function clearMessages() { errorMessage.textContent = ''; successMessage.textContent = ''; retryMessage.textContent = '';}

    // Enable/disable copy and share buttons based on content presence
    function updateActionButtonsState(rawText) {
        const hasContent = !!rawText && rawText.trim().length > 0;
        copyButton.disabled = !hasContent;
        if (isShareSupported && shareButton) {
            shareButton.disabled = !hasContent;
        }
    }


    // --- PWA Service Worker Registration ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            // Adjust the path based on your deployment structure
            navigator.serviceWorker.register('/ArticleScraper/sw.js') // Assuming sw.js is in the ArticleScraper subdirectory
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                })
                .catch(err => {
                    console.error('ServiceWorker registration failed: ', err);
                });
        });
    }
    // --- END PWA Service Worker Registration ---

    // --- HANDLE INCOMING SHARE TARGET ---
    function handleIncomingShare() {
        const urlParams = new URLSearchParams(window.location.search);
        const sharedUrl = urlParams.get('url');
        const sharedText = urlParams.get('text');
        let textToInput = '';

        if (sharedUrl) {
            console.log("Received shared URL:", sharedUrl);
            textToInput = sharedUrl;
        } else if (sharedText) {
            console.log("Received shared text:", sharedText);
            // Attempt to extract a URL from the shared text
            const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
            const match = sharedText.match(urlRegex);
            if (match) {
                textToInput = match[0];
                console.log("Extracted URL from shared text:", textToInput);
            } else {
                // If no URL found in text, maybe use the text itself?
                // For this app, we primarily want URLs.
                // textToInput = sharedText; // Uncomment if you want to process raw text
                console.log("Shared text received, but no URL found within it.");
            }
        }

        if (textToInput && urlInput) {
            urlInput.value = textToInput;
            console.log("Populated input field with shared data.");
            // Automatically trigger extraction if not already processing/reset
            if (!isInResetMode && extractButton.getAttribute('aria-busy') !== 'true') {
                 console.log("Auto-triggering extraction from share...");
                triggerExtractionDebounced();
            } else {
                 console.log("Skipping auto-trigger due to current state (reset mode or busy).");
            }
             // Clean the URL params from the address bar after processing
             if (window.history.replaceState) {
                const cleanUrl = window.location.pathname; // Keep only the path
                window.history.replaceState({}, document.title, cleanUrl);
             }
        }
    }
    // Run share target handler on load
    window.addEventListener('load', handleIncomingShare);
    // --- END INCOMING SHARE TARGET ---

</script>

</body>
</html>