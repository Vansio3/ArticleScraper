<!DOCTYPE html>
<html lang="en" data-theme="dark"> <!-- Force dark theme with Pico -->
<head>
<title>Modern Article Extractor</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="dark light"> <!-- Indicate theme support -->

<!-- Pico.css - Include BEFORE custom styles -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@latest/css/pico.min.css">

<style>
  /* --- Custom Styles & Overrides (Mobile First) --- */

  /* Add some vertical spacing */
  main.container {
    padding-top: calc(var(--pico-spacing) * 2);
    padding-bottom: calc(var(--pico-spacing) * 2);
    margin-top: var(--pico-spacing);
    margin-bottom: var(--pico-spacing);
  }

  h1 {
     font-size: 1.75em; /* Slightly adjust Pico's h1 */
     margin-bottom: var(--pico-block-spacing-vertical);
  }

  /* Layout for Input + Button */
  #input-area {
      display: grid; /* Use grid for potentially better alignment */
      grid-template-columns: 1fr; /* Stack on mobile */
      gap: var(--pico-form-element-spacing-vertical);
      margin-bottom: var(--pico-block-spacing-vertical);
  }

  /* Keep textarea monospace */
  #extracted-text {
    font-family: var(--pico-font-monospace);
    height: 250px; /* Default mobile height */
    resize: vertical;
     /* Pico might add margin, ensure it's inside the details */
     margin-bottom: 0;
  }

  /* Center the copy button */
   #copy-button-wrapper {
       margin-bottom: calc(var(--pico-spacing) / 2);
       display: block; /* Ensure it takes block space */
       text-align: center; /* Center the inline-block button */
   }
   #copy-button {
        display: inline-block; /* Allow text align to center it */
        width: auto; /* Don't force full width unless needed */
        padding-left: calc(var(--pico-spacing) * 1.5); /* More horizontal padding */
        padding-right: calc(var(--pico-spacing) * 1.5);
   }

  /* Style the details/summary trigger */
  details summary {
      /* Pico styles this well, minor adjustments if needed */
      font-weight: var(--pico-font-weight-semibold);
      margin-top: var(--pico-spacing); /* Space below copy button */
  }

  /* Spacing inside the details */
  details > div {
      padding-top: var(--pico-form-element-spacing-vertical);
  }

  /* Status messages */
  #status-messages {
      margin-top: var(--pico-block-spacing-vertical);
      min-height: 1.5em;
      text-align: center;
      font-weight: var(--pico-font-weight-medium);
      font-size: 0.9em;
  }

  #error-message {
    color: var(--pico-color-red-500); /* Use Pico variable */
  }

  #success-message {
    color: var(--pico-color-green-500); /* Use Pico variable */
  }

  #loading-indicator {
      display: none;
      text-align: center;
      margin: var(--pico-block-spacing-vertical) 0;
      color: var(--pico-secondary);
  }


  /* --- Tablet & Larger Screens --- */
  @media (min-width: 768px) { /* Pico's default breakpoint is often 768px */
    h1 {
        font-size: 2em;
    }

    #input-area {
        grid-template-columns: 1fr auto; /* Input takes space, button fits content */
        gap: var(--pico-form-element-spacing-horizontal);
        align-items: flex-end; /* Align items to bottom edge */
    }

    /* Label specific alignment if needed when side-by-side */
    #input-area label {
        /* margin-bottom: 0; */ /* Optional: remove bottom margin if aligned */
    }


    #extracted-text {
        height: 300px; /* More height on larger screens */
    }
  }

  /* Desktops and up */
  @media (min-width: 992px) {
     #extracted-text {
        height: 350px;
     }
  }

</style>
</head>
<body>

<!-- Use main.container as recommended by Pico -->
<main class="container">
    <h1>Article Extractor</h1>

    <!-- Removed outer #input-container div -->
    <label for="url-input">Enter URL or text containing a URL:</label>
    <div id="input-area">
        <input type="text" id="url-input" name="url-input" placeholder="e.g., https://example.com/article">
        <!-- Pico styles buttons automatically -->
        <button id="extract-button">Extract Text</button>
    </div>

    <div id="loading-indicator">
        Fetching and processing content... <progress></progress> <!-- Pico styles progress -->
    </div>

    <!-- Removed outer #output-container div -->
    <!-- Wrapper for copy button centering -->
    <div id="copy-button-wrapper">
       <button id="copy-button" disabled>Copy Extracted Text</button>
    </div>

    <!-- Pico styles details/summary nicely -->
    <details id="extracted-content-details">
        <summary>View Extracted Text</summary>
        <!-- Div needed inside details for padding -->
        <div>
            <textarea id="extracted-text" name="extracted-text" readonly placeholder="Extracted text will appear here..."></textarea>
        </div>
    </details>

    <div id="status-messages">
        <div id="error-message"></div>
        <div id="success-message"></div>
    </div>
</main> <!-- End .container -->


<!-- ***** INCLUDE Readability.js SCRIPT HERE ***** -->
<script src="readability.js"></script>
<!-- Make sure readability.js file is in the same directory -->


<script>
  // Get reference to elements
  const urlInput = document.getElementById('url-input');
  const extractButton = document.getElementById('extract-button');
  const loadingIndicator = document.getElementById('loading-indicator');
  const extractedText = document.getElementById('extracted-text');
  const copyButton = document.getElementById('copy-button');
  const errorMessage = document.getElementById('error-message');
  const successMessage = document.getElementById('success-message');
  const detailsElement = document.getElementById('extracted-content-details');

  // References to the progress element inside the indicator
  const progressIndicator = loadingIndicator.querySelector('progress');


  extractButton.addEventListener('click', handleExtraction);
  copyButton.addEventListener('click', copyTextToClipboard);

  function handleExtraction() {
    resetUI();

    const inputText = urlInput.value.trim();
    if (!inputText) {
        displayError("Please enter text containing a URL.");
        return;
    }

    const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
    const match = inputText.match(urlRegex);

    if (!match) {
      displayError("No valid URL found in the input.");
      return;
    }

    const targetUrl = match[0];
    console.log("Extracted URL:", targetUrl);

    const corsProxyUrl = 'https://api.allorigins.win/raw?url=';
    const proxiedUrl = corsProxyUrl + encodeURIComponent(targetUrl);

    setLoadingState(true); // Show loading indicator

    fetch(proxiedUrl)
      .then(response => {
        if (!response.ok) {
          let errorMsg = `Proxy fetch failed: ${response.status} ${response.statusText}`;
          if (response.status === 404) errorMsg += ". URL not found via proxy.";
          else if (response.status === 403) errorMsg += ". Access denied (proxy blocked?).";
          else if (response.status >= 500) errorMsg += ". Proxy server error.";
          throw new Error(errorMsg);
        }
        return response.text();
      })
      .then(html => {
        let doc;
        try {
            const parser = new DOMParser();
            doc = parser.parseFromString(html, 'text/html');
        } catch (parseError) {
            console.error("DOM Parsing Error:", parseError);
            throw new Error("Failed to parse the HTML content.");
        }

        let article = null;
        if (typeof Readability === 'undefined') {
            console.warn("Readability.js not loaded. Falling back.");
        } else {
            try {
                 const documentClone = doc.cloneNode(true);
                 let reader = new Readability(documentClone);
                 article = reader.parse();
            } catch (readabilityError) {
                console.error("Readability Error:", readabilityError);
            }
        }

        let extractionSource = '';

        if (article && article.textContent && article.textContent.trim().length > 100) {
            extractedText.value = article.textContent.trim();
            extractionSource = 'Readability';
        } else {
             if (!article && typeof Readability !== 'undefined') {
                 console.log("Readability failed or content insufficient, attempting fallback...");
             } else if (typeof Readability === 'undefined') {
                 // Already warned if undefined
             } else {
                  console.log("Readability content insufficient, attempting fallback...");
             }

            const mainElement = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.post-content') || doc.querySelector('.entry-content') || doc.body;

            if (mainElement) {
                const scripts = mainElement.querySelectorAll('script, style, nav, header, footer, aside, .sidebar, .ads, [aria-hidden="true"], noscript, form, button, input, figure, figcaption, .share-buttons, .comments-area'); // Even more cleanup targets
                scripts.forEach(el => el.remove());
                // More aggressive whitespace cleanup
                extractedText.value = mainElement.textContent
                                       .replace(/[\t\r\n]+/g, '\n') // Collapse multiple line breaks/tabs/returns to single newline
                                       .replace(/\n\s*\n/g, '\n\n') // Ensure max one blank line
                                       .replace(/ {2,}/g, ' ') // Collapse multiple spaces
                                       .trim();
            } else {
                 extractedText.value = doc.body ? doc.body.textContent.trim().replace(/\s\s+/g, ' ') : '';
            }

            if (extractedText.value.trim().length > 50) {
                 if (!article && typeof Readability !== 'undefined') {
                      extractionSource = 'basic fallback (Readability failed)';
                 } else {
                      extractionSource = 'basic fallback';
                 }
            } else {
                 extractedText.value = '';
            }
        }

        if (extractionSource) {
            displaySuccess(`Extracted using ${extractionSource}.`);
            enableCopyButton();
            detailsElement.open = true;
        } else {
             let finalError = "Extraction failed: Could not get meaningful content.";
             if (typeof Readability === 'undefined'){
                  finalError = "Extraction failed: Readability script missing & fallback found no content.";
             }
            displayError(finalError);
            copyButton.disabled = true;
            detailsElement.open = false;
        }

      })
      .catch(error => {
        console.error("Error during fetch or extraction:", error);
        displayError(`Error: ${error.message}`);
        detailsElement.open = false;
      })
      .finally(() => {
        setLoadingState(false); // Hide loading indicator
      });
  }

   function setLoadingState(isLoading) {
        if (isLoading) {
            loadingIndicator.style.display = 'block';
            if (progressIndicator) progressIndicator.removeAttribute('value'); // Indeterminate progress
            extractButton.setAttribute('aria-busy', 'true'); // Pico uses aria-busy for buttons
            extractButton.disabled = true;
        } else {
            loadingIndicator.style.display = 'none';
            extractButton.removeAttribute('aria-busy');
            extractButton.disabled = false;
        }
    }


  function copyTextToClipboard() {
    if (!extractedText.value) {
        displayError("Nothing to copy.");
        return;
    }

    if (!detailsElement.open) {
        detailsElement.open = true;
    }

    navigator.clipboard.writeText(extractedText.value)
      .then(() => {
        displaySuccess("Content copied to clipboard!");
        const originalText = 'Copy Extracted Text';
        copyButton.textContent = 'Copied!';
        copyButton.classList.add('secondary'); // Pico class for visual feedback
        setTimeout(() => {
            copyButton.textContent = originalText;
            copyButton.classList.remove('secondary');
        }, 1500);
      })
      .catch(err => {
        console.error('Failed to copy text: ', err);
        try {
            detailsElement.open = true;
            extractedText.select();
            document.execCommand('copy');
            displaySuccess("Copied (using fallback)!");
        } catch (execErr) {
             displayError("Failed to copy automatically.");
        }
      });
  }

  function resetUI() {
    errorMessage.textContent = '';
    successMessage.textContent = '';
    setLoadingState(false); // Ensure loading state is off
    copyButton.disabled = true;
    copyButton.textContent = 'Copy Extracted Text';
    copyButton.classList.remove('secondary'); // Ensure feedback class is removed
    detailsElement.open = false;
    // Optional: Clear text area on reset?
    // extractedText.value = '';
  }

  function displayError(message) {
    errorMessage.textContent = message;
    successMessage.textContent = '';
  }

  function displaySuccess(message) {
    successMessage.textContent = message;
    errorMessage.textContent = '';
  }

  function enableCopyButton() {
    if(extractedText.value.trim()){
        copyButton.disabled = false;
    } else {
        copyButton.disabled = true;
    }
  }

</script>

</body>
</html>