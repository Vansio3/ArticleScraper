<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<title>Modern Article Extractor</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="dark light">

<!-- Pico.css - Include BEFORE custom styles -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@latest/css/pico.min.css">

<style>
  /* --- Custom Styles & Overrides --- */
  :root {
      --pico-color-amber-500: #ffa000;
      --pico-border-radius-pill: 50px;
      --animation-duration: 0.5s; /* Control animation speed */
      --animation-delay: 0.2s; /* Delay for appearing elements */
  }

  * {
      box-sizing: border-box; /* Ensure padding/border included in size */
  }

  /* --- Body Layout for Centering/Top Alignment --- */
  body {
    font-family: var(--pico-font-family);
    margin: 0;
    padding: var(--pico-spacing); /* Padding around edges */
    line-height: 1.6;
    background-color: var(--pico-background-color);
    color: var(--pico-color);
    display: flex;
    flex-direction: column;
    /* Initial state: Center content */
    justify-content: center;
    align-items: center;
    min-height: 100vh; /* Ensure body takes full viewport height */
    /* Smooth transition for the layout change (optional, can be slightly jerky) */
    /* transition: justify-content var(--animation-duration) ease-in-out; */
    overflow-x: hidden; /* Prevent horizontal scroll during minor shifts */
  }

  /* Final state: Align content to top */
  body.state-extracted {
    justify-content: flex-start;
  }
  /* --- End Body Layout --- */


  main.container {
    width: 100%; /* Take full width within constraints */
    max-width: 700px; /* Max width */
    padding: calc(var(--pico-spacing) * 1.5); /* Use Pico spacing */
    border-radius: var(--pico-border-radius);
    /* Use card styles for background/border */
    background-color: var(--pico-card-background-color);
    border: var(--pico-card-border-width) solid var(--pico-card-border-color);
    box-shadow: var(--pico-card-box-shadow);
    /* Animate margin changes for smooth slide-up */
    transition: margin var(--animation-duration) ease-in-out;
    /* Ensure it doesn't grow when centered */
    flex-shrink: 0;
     margin-top: 0; /* Start with no top margin when centered */
     margin-bottom: var(--pico-spacing); /* Some bottom margin */
  }

  /* Give container top margin in the final state */
  body.state-extracted main.container {
       margin-top: calc(var(--pico-spacing) * 3); /* Push down from top */
       margin-bottom: calc(var(--pico-spacing) * 3);
  }

  h1 {
     text-align: center; /* Center heading */
     font-size: 1.75em;
     margin-bottom: var(--pico-block-spacing-vertical);
  }

  /* --- Input Group Styling (Search Bar Look) --- */
  #input-label {
      /* Use Pico's label styling, just ensure spacing */
      margin-bottom: var(--pico-form-element-spacing-vertical);
      display: block; /* Make sure it takes its own line */
      text-align: center; /* Center label */
  }

  #input-group {
      display: flex;
      align-items: center;
      background-color: var(--pico-form-element-background-color);
      border-radius: var(--pico-border-radius-pill);
      border: var(--pico-border-width) solid var(--pico-form-element-border-color);
      padding: 0;
      overflow: hidden;
      transition: border-color var(--pico-transition), box-shadow var(--pico-transition);
      margin-bottom: var(--pico-block-spacing-vertical); /* Space below group */
  }

  #input-group:focus-within {
       border-color: var(--pico-primary);
       box-shadow: 0 0 0 var(--pico-outline-width) var(--pico-primary-focus);
  }

  #url-input {
      flex-grow: 1;
      border: none;
      background-color: transparent;
      padding: var(--pico-form-element-spacing-vertical) var(--pico-form-element-spacing-horizontal);
      padding-right: calc(var(--pico-form-element-spacing-horizontal) / 2);
      font-size: 1em;
      color: var(--pico-form-element-color);
      outline: none;
      margin: 0;
      min-width: 0;
  }
  #url-input::placeholder {
      color: var(--pico-secondary);
  }

  /* --- Extract Button Style --- */
  #extract-button {
      flex-shrink: 0;
      border: none;
      background-color: var(--pico-primary);
      color: var(--pico-primary-inverse);
      margin: 4px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4em;
      font-weight: bold;
      line-height: 1;
      width: 2.4em;
      height: 2.4em;
      padding: 0;
      transition: background-color var(--pico-transition), transform 0.1s ease, color 0.1s ease;
      position: relative;
      overflow: hidden;
  }
  #extract-button:hover:not([aria-busy=true]) {
      background-color: var(--pico-primary-hover);
  }
  #extract-button:active:not([aria-busy=true]) {
      transform: scale(0.95);
  }
  /* Style for loading state */
  #extract-button[aria-busy=true] {
      background-color: var(--pico-secondary);
      cursor: default;
      color: transparent;
  }
  /* Rule to center Pico's spinner */
  #extract-button[aria-busy=true]::before {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      margin: 0 !important;
  }
  /* --- END EXTRACT BUTTON STYLE --- */


  /* --- MODERN COPY BUTTON STYLES --- */
   #copy-button-wrapper {
       margin-bottom: calc(var(--pico-spacing) / 2);
       display: block;
       text-align: center;
   }
  #copy-button {
      background-color: var(--pico-card-background-color);
      color: var(--pico-contrast-foreground);
      border: 1px solid var(--pico-contrast-border);
      padding: calc(var(--pico-spacing) * 0.6) calc(var(--pico-spacing) * 1.2);
      border-radius: var(--pico-border-radius);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: calc(var(--pico-spacing) * 0.5);
      transition: background-color var(--pico-transition), border-color var(--pico-transition), transform 0.1s ease, box-shadow var(--pico-transition), opacity var(--animation-duration) ease-out, transform var(--animation-duration) ease-out; /* Add opacity/transform */
      cursor: pointer;
      font-weight: var(--pico-font-weight-medium);
      width: auto;
  }
  #copy-button .icon-wrapper { display: inline-flex; align-items: center; line-height: 0; }
  #copy-button svg { width: 1.1em; height: 1.1em; fill: currentColor; }
  #copy-button:not(:disabled):hover { background-color: var(--pico-contrast-hover-background); border-color: var(--pico-contrast-hover-border); transform: translateY(-1px); box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15); }
  #copy-button:not(:disabled):active { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
  #copy-button:disabled { background-color: var(--pico-card-background-color); color: var(--pico-contrast-foreground); border-color: var(--pico-contrast-border); opacity: 0.4; cursor: not-allowed; box-shadow: none; transform: none; }
  #copy-button.secondary { background-color: var(--pico-secondary-background); border-color: var(--pico-secondary-border); color: var(--pico-secondary-foreground); }
  /* --- END COPY BUTTON STYLES --- */


  /* --- Details/Textarea Styles --- */
  #extracted-text {
    font-family: var(--pico-font-monospace);
    height: 250px;
    resize: vertical;
    margin-bottom: 0;
  }

  details {
      /* Apply transition for animation */
       transition: opacity calc(var(--animation-duration) / 1.5) ease-out var(--animation-delay),
                  transform calc(var(--animation-duration) / 1.5) ease-out var(--animation-delay),
                  max-height calc(var(--animation-duration) / 1.5) ease-in-out var(--animation-delay);
       will-change: opacity, transform, max-height;
  }

  details summary {
      font-weight: var(--pico-font-weight-semibold);
      margin-top: var(--pico-spacing);
  }

  details > div {
      padding-top: var(--pico-form-element-spacing-vertical);
  }
  /* --- End Details/Textarea --- */


  /* --- Status Messages --- */
  #status-messages {
      margin-top: var(--pico-block-spacing-vertical);
      min-height: 1.5em;
      text-align: center;
      font-weight: var(--pico-font-weight-medium);
      font-size: 0.9em;
  }
  #error-message { color: var(--pico-color-red-500); }
  #success-message { color: var(--pico-color-green-500); }
  #retry-message { color: var(--pico-color-amber-500); }
  /* --- End Status --- */


  /* --- HIDE & ANIMATE OUTPUT SECTIONS --- */
  #copy-button-wrapper,
  #extracted-content-details {
      /* Start hidden and slightly down */
      display: block; /* Keep block for layout */
      opacity: 0;
      transform: translateY(15px);
      /* Set initial height to 0 and overflow hidden */
      max-height: 0;
      overflow: hidden;
  }

  /* Show/Animate In when body has class */
  body.state-extracted #copy-button-wrapper,
  body.state-extracted #extracted-content-details {
      opacity: 1;
      transform: translateY(0);
      /* Set max-height large enough to accommodate content */
      max-height: 1000px; /* Adjust if needed, needs to be bigger than expected content */
      /* Apply transitions (defined on elements themselves now) */
  }
  /* --- END HIDE & ANIMATE --- */


  /* --- Media Queries --- */
  @media (min-width: 768px) {
    h1 { font-size: 2em; }
    #extracted-text { height: 300px; }
  }
  @media (min-width: 992px) {
     #extracted-text { height: 350px; }
  }

</style>
</head>
<body>

<!-- Container gets centered/moved by body flex rules -->
<main class="container">
    <h1>Article Extractor</h1>

    <label for="url-input" id="input-label">Enter URL or text containing a URL:</label>
    <div id="input-group">
        <input type="text" id="url-input" name="url-input" placeholder="Paste URL or text here...">
        <button id="extract-button" title="Extract Text">
            →
        </button>
    </div>

    <!-- Output sections start hidden via CSS, shown when body gets .state-extracted -->
    <div id="copy-button-wrapper">
       <button id="copy-button" disabled>
            <span class="icon-wrapper"></span>
            <span class="text-wrapper">Copy Extracted Text</span>
       </button>
    </div>

    <details id="extracted-content-details">
        <summary>View Extracted Text</summary>
        <div>
            <textarea id="extracted-text" name="extracted-text" readonly placeholder="Extracted text will appear here..."></textarea>
        </div>
    </details>

    <div id="status-messages">
        <div id="retry-message"></div>
        <div id="error-message"></div>
        <div id="success-message"></div>
    </div>
</main>

<!-- ***** INCLUDE Readability.js SCRIPT HERE ***** -->
<script src="readability.js"></script>

<script>
    // --- Constants ---
  const PROXY_URL = 'https://api.allorigins.win/raw?url=';
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 1500;
  const DEBOUNCE_DELAY_MS = 500;
  const TEXT_PREFIX = "Summarise the key points from the following article:\n\n";

  // --- SVG Icons ---
  const ICON_COPY_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-copy"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>`;
  const ICON_CHECK_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;


  // --- Element References ---
  const urlInput = document.getElementById('url-input');
  const extractButton = document.getElementById('extract-button');
  const extractedText = document.getElementById('extracted-text');
  const copyButton = document.getElementById('copy-button');
  const copyButtonIconWrapper = copyButton.querySelector('.icon-wrapper');
  const copyButtonTextWrapper = copyButton.querySelector('.text-wrapper');
  const errorMessage = document.getElementById('error-message');
  const successMessage = document.getElementById('success-message');
  const retryMessage = document.getElementById('retry-message');
  const detailsElement = document.getElementById('extracted-content-details');
  const copyButtonWrapper = document.getElementById('copy-button-wrapper');

  // --- Debounce Timer ---
  let debounceTimer;

  // --- Initial Setup ---
  function setInitialCopyIcon() {
      if (copyButtonIconWrapper) {
          copyButtonIconWrapper.innerHTML = ICON_COPY_SVG;
      }
  }
  setInitialCopyIcon(); // Set the icon when the script loads


  // --- Event Listeners ---
  extractButton.addEventListener('click', () => {
      if (extractButton.getAttribute('aria-busy') === 'true') return;
      clearTimeout(debounceTimer);
      // Don't call handleExtraction immediately, debounce timer does
      debounceTimer = setTimeout(handleExtraction, DEBOUNCE_DELAY_MS);
  });
  urlInput.addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
          event.preventDefault();
          if (extractButton.getAttribute('aria-busy') === 'true') return;
          clearTimeout(debounceTimer);
          // Don't call handleExtraction immediately, debounce timer does
          debounceTimer = setTimeout(handleExtraction, DEBOUNCE_DELAY_MS);
      }
  });
  copyButton.addEventListener('click', copyTextToClipboard);

  // --- Core Logic ---
  function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function fetchWithRetries(url, options, retries = MAX_RETRIES) {
      for (let i = 0; i <= retries; i++) {
          try {
              if (i > 0) {
                  displayRetryMessage(`Attempt ${i+1} of ${retries+1}...`);
                  await delay(RETRY_DELAY_MS * i);
              }
              const response = await fetch(url, options);
              if (!response.ok) {
                  if (response.status >= 500 && response.status < 600 && i < retries) {
                      console.warn(`Attempt ${i+1} failed with status ${response.status}. Retrying...`);
                      continue;
                  }
                  throw new Error(`Proxy fetch failed: ${response.status} ${response.statusText}`);
              }
              clearRetryMessage();
              return response;
          } catch (error) {
              console.error(`Attempt ${i+1} caught error:`, error);
              if (i === retries) {
                  clearRetryMessage();
                  throw error;
              }
          }
      }
      throw new Error("Fetch failed after all retries.");
  }

  async function handleExtraction() {
    // Clear previous results visually *before* starting fetch
    resetOutputState();
    const inputText = urlInput.value.trim();
    if (!inputText) { displayError("Please enter text containing a URL."); return; }
    const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
    const match = inputText.match(urlRegex);
    if (!match) { displayError("No valid URL found in the input."); return; }
    const targetUrl = match[0];
    console.log("Extracted URL:", targetUrl);
    const proxiedUrl = PROXY_URL + encodeURIComponent(targetUrl);

    setLoadingState(true); // Set button to busy

    try {
        const response = await fetchWithRetries(proxiedUrl);
        const html = await response.text();
        let doc;
        try { const parser = new DOMParser(); doc = parser.parseFromString(html, 'text/html'); }
        catch (parseError) { console.error("DOM Parsing Error:", parseError); throw new Error("Failed to parse the HTML content."); }
        let article = null;
        if (typeof Readability === 'undefined') { console.warn("Readability.js not loaded. Falling back."); }
        else { try { const documentClone = doc.cloneNode(true); let reader = new Readability(documentClone); article = reader.parse(); }
               catch (readabilityError) { console.error("Readability Error:", readabilityError); } }

        let extractionSource = '';
        let rawExtractedText = ''; // Holds final text *before* prefix

        // Process Readability result (with Title handling)
        if (article && article.textContent && article.textContent.trim().length > 100) {
            const title = article.title?.trim();
            const bodyText = article.textContent.trim();
            if (title) { rawExtractedText = `${title}\n\n${bodyText}`; }
            else { rawExtractedText = bodyText; }
            extractionSource = 'Readability';
        } else {
             // Fallback logic
            if (extractionSource === '') { if (!article && typeof Readability !== 'undefined') console.log("Readability failed/insufficient, attempting fallback..."); else if (typeof Readability === 'undefined') {} else console.log("Readability content insufficient, attempting fallback..."); }
            const mainElement = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.post-content') || doc.querySelector('.entry-content') || doc.body;
            if (mainElement) {
                const scripts = mainElement.querySelectorAll('script, style, nav, header, footer, aside, .sidebar, .ads, [aria-hidden="true"], noscript, form, button, input, figure, figcaption, .share-buttons, .comments-area');
                scripts.forEach(el => el.remove());
                rawExtractedText = mainElement.textContent.replace(/[\t\r\n]+/g, '\n').replace(/\n\s*\n/g, '\n\n').replace(/ {2,}/g, ' ').trim();
            } else { rawExtractedText = doc.body ? doc.body.textContent.trim().replace(/\s\s+/g, ' ') : ''; }
            if (rawExtractedText.trim().length > 50) { if (!article && typeof Readability !== 'undefined') extractionSource = 'basic fallback (Readability failed)'; else extractionSource = 'basic fallback'; }
            else { rawExtractedText = ''; }
        }

        // Update UI based on combined result
        if (extractionSource) {
            extractedText.value = TEXT_PREFIX + rawExtractedText; // Add prefix
            document.body.classList.add('state-extracted'); // << TRIGGER ANIMATION
            displaySuccess(`Extracted using ${extractionSource}.`);
            enableCopyButton();
            // Showing is now handled by CSS via body class
            detailsElement.open = true; // Still need to open details
        } else {
             extractedText.value = ''; // Clear text area
             let finalError = "Extraction failed: Could not get meaningful content.";
             if (typeof Readability === 'undefined'){ finalError = "Extraction failed: Readability script missing & fallback failed."; }
            displayError(finalError);
            document.body.classList.remove('state-extracted'); // Ensure class removed
            copyButton.disabled = true;
            detailsElement.open = false;
        }
    } catch (error) {
        console.error("Error during fetch or extraction:", error);
        extractedText.value = ''; // Clear text area
        displayError(`Error: ${error.message}`);
        document.body.classList.remove('state-extracted'); // Ensure class removed
        detailsElement.open = false;
    } finally {
        setLoadingState(false); // Set button back to normal
    }
  }

   function setLoadingState(isLoading) {
        // Only manage the button's busy state now
        if (isLoading) { extractButton.setAttribute('aria-busy', 'true'); }
        else { extractButton.removeAttribute('aria-busy'); }
    }

  // --- Clipboard and UI Functions ---
  function copyTextToClipboard() {
    if (!extractedText.value) { displayError("Nothing to copy."); return; }
    if (!detailsElement.open) { detailsElement.open = true; }

    navigator.clipboard.writeText(extractedText.value)
      .then(() => {
        displaySuccess("Content copied to clipboard!");
        if (copyButtonIconWrapper) copyButtonIconWrapper.innerHTML = ICON_CHECK_SVG;
        if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copied!';
        copyButton.classList.add('secondary');

        setTimeout(() => {
            setInitialCopyIcon();
             if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy Extracted Text';
            copyButton.classList.remove('secondary');
        }, 2000);

      })
      .catch(err => {
          console.error('Failed to copy text: ', err);
          try { detailsElement.open = true; extractedText.select(); document.execCommand('copy'); displaySuccess("Copied (using fallback)!"); }
          catch (execErr) { displayError("Failed to copy automatically."); }
      });
  }

   // Resets only output state, not layout
  function resetOutputState() {
    errorMessage.textContent = '';
    successMessage.textContent = '';
    retryMessage.textContent = '';
    copyButton.disabled = true;
    setInitialCopyIcon();
     if (copyButtonTextWrapper) copyButtonTextWrapper.textContent = 'Copy Extracted Text';
    copyButton.classList.remove('secondary');
    detailsElement.open = false;
    extractedText.value = ''; // Clear old text
    // Hiding handled by removing body class in resetUI
  }

  // Full reset including layout
  function resetUI() {
    resetOutputState(); // Clear output content and state
    document.body.classList.remove('state-extracted'); // << REMOVE CLASS TO RESET LAYOUT
    setLoadingState(false);
    // urlInput.value = ''; // Optional: Clear input on full reset?
  }

  function displayError(message) { errorMessage.textContent = message; successMessage.textContent = ''; retryMessage.textContent = ''; }
  function displaySuccess(message) { successMessage.textContent = message; errorMessage.textContent = ''; retryMessage.textContent = ''; }
  function displayRetryMessage(message) { retryMessage.textContent = message; errorMessage.textContent = ''; successMessage.textContent = ''; }
  function clearRetryMessage() { retryMessage.textContent = ''; }
  function enableCopyButton() { if(extractedText.value.trim().length >= TEXT_PREFIX.length){ copyButton.disabled = false; } else { copyButton.disabled = true; } }

</script>

</body>
</html>