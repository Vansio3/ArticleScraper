<!DOCTYPE html>
<html lang="en">
<head>
<title>Article Text Extractor</title>
<meta charset="UTF-8">
<!-- Crucial for responsiveness: sets viewport width and initial scale -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  /* --- Global Styles & Mobile First Base --- */
  :root {
    --primary-color: #007bff;
    --primary-hover-color: #0056b3;
    --error-color: #dc3545;
    --success-color: #28a745;
    --text-color: #333;
    --light-gray: #f4f4f4;
    --medium-gray: #ccc;
    --white: #fff;
    --border-radius: 4px;
    --spacing-unit: 15px; /* Base spacing */
  }

  * {
    box-sizing: border-box; /* Include padding and border in element's total width/height */
    margin: 0;
    padding: 0;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    margin: 0; /* Remove default body margin */
    padding: var(--spacing-unit); /* Add padding around the content */
    line-height: 1.6;
    background-color: var(--light-gray);
    color: var(--text-color);
    display: flex; /* Use flexbox for centering container */
    flex-direction: column;
    align-items: center; /* Center content horizontally */
    min-height: 100vh; /* Ensure body takes at least full viewport height */
  }

  .container {
     width: 100%; /* Full width on mobile */
     max-width: 700px; /* Max width for larger screens, defined later */
     background-color: var(--white);
     padding: var(--spacing-unit);
     border-radius: calc(var(--border-radius) * 2);
     box-shadow: 0 2px 8px rgba(0,0,0,0.1);
     margin-bottom: var(--spacing-unit);
  }

  h1 {
    color: var(--primary-hover-color);
    text-align: center;
    font-size: 1.8em; /* Relative font size */
    margin-bottom: calc(var(--spacing-unit) * 1.5);
  }

  label {
    display: block;
    margin-bottom: calc(var(--spacing-unit) / 3);
    font-weight: bold;
    font-size: 0.95em;
  }

  #input-area {
      display: flex;
      flex-direction: column; /* Stack input and button on mobile */
      gap: calc(var(--spacing-unit) / 2); /* Space between input and button */
  }

  #url-input {
    width: 100%; /* Full width */
    padding: calc(var(--spacing-unit) * 0.7);
    border: 1px solid var(--medium-gray);
    border-radius: var(--border-radius);
    font-size: 1em;
  }

  #extract-button,
  #copy-button {
    width: 100%; /* Full width button on mobile */
    padding: calc(var(--spacing-unit) * 0.75) var(--spacing-unit);
    cursor: pointer;
    background-color: var(--primary-color);
    color: var(--white);
    border: none;
    border-radius: var(--border-radius);
    font-size: 1em;
    font-weight: bold;
    text-align: center;
    transition: background-color 0.2s ease, transform 0.1s ease;
  }

  #extract-button:hover,
  #copy-button:hover:not(:disabled) {
    background-color: var(--primary-hover-color);
  }

  #extract-button:active,
  #copy-button:active:not(:disabled) {
      transform: scale(0.98); /* Subtle press effect */
  }

  #copy-button {
    margin-top: calc(var(--spacing-unit) / 2); /* Space above copy button */
  }

  #copy-button:disabled {
    background-color: var(--medium-gray);
    cursor: not-allowed;
  }

  #loading-indicator {
    display: none; /* Hidden by default */
    margin: var(--spacing-unit) 0;
    text-align: center;
    font-style: italic;
    color: #555;
  }

  #extracted-text {
    width: 100%;
    height: 250px; /* Slightly smaller default height for mobile */
    padding: calc(var(--spacing-unit) * 0.7);
    border: 1px solid var(--medium-gray);
    border-radius: var(--border-radius);
    margin-bottom: 0; /* Remove margin, space handled by copy button */
    font-family: monospace;
    white-space: pre-wrap;
    font-size: 0.9em;
    resize: vertical; /* Allow vertical resize only */
  }

  #status-messages {
      margin-top: var(--spacing-unit);
      min-height: 1.5em;
      text-align: center;
      font-weight: bold;
      font-size: 0.9em;
  }

  #error-message {
    color: var(--error-color);
  }

  #success-message {
    color: var(--success-color);
  }

  /* --- Tablet & Larger Screens (min-width media queries) --- */

  /* Small tablets and up */
  @media (min-width: 600px) {
    h1 {
        font-size: 2.2em;
    }

    .container {
        padding: calc(var(--spacing-unit) * 1.5);
    }

    #input-area {
        flex-direction: row; /* Input and button side-by-side */
        align-items: center; /* Align items vertically */
    }

    #url-input {
        flex-grow: 1; /* Allow input to take available space */
        /* Width is now controlled by flexbox, remove explicit width */
    }

    #extract-button {
        width: auto; /* Button takes its natural width */
        flex-shrink: 0; /* Prevent button from shrinking */
    }

    #extracted-text {
        height: 300px; /* Increase height a bit */
        font-size: 0.95em;
    }

    #copy-button {
        width: auto; /* Auto width for copy button too */
        display: inline-block; /* Allow text-align center on parent to work */
    }

     #output-container {
        text-align: center; /* Center the inline-block copy button */
    }
  }

  /* Desktops and up */
  @media (min-width: 992px) {
    /* Optional: Slightly larger fonts or spacing for very large screens */
     body {
        padding: calc(var(--spacing-unit) * 1.5);
     }
     .container {
        padding: calc(var(--spacing-unit) * 2);
     }
     #extracted-text {
        height: 350px; /* Even more height */
     }
  }

</style>
</head>
<body>

<!-- Wrap main content in a container for centering and max-width -->
<div class="container">
    <h1>Article Text Extractor</h1>

    <div id="input-container">
      <label for="url-input">Enter URL or text containing a URL:</label>
      <!-- New div for input+button flex layout -->
      <div id="input-area">
          <input type="text" id="url-input" placeholder="e.g., https://example.com/article">
          <button id="extract-button">Extract Text</button>
      </div>
    </div>

    <div id="loading-indicator">
        Fetching and processing content...
    </div>

    <div id="output-container">
      <label for="extracted-text">Extracted Text:</label>
      <textarea id="extracted-text" readonly placeholder="Extracted text will appear here"></textarea>
      <button id="copy-button" disabled>Copy Text</button>
    </div>

    <div id="status-messages">
        <div id="error-message"></div>
        <div id="success-message"></div>
    </div>
</div> <!-- End .container -->


<!--
    **IMPORTANT: Include Readability.js here**
    1. Download `Readability.js` from: https://github.com/mozilla/readability
    2. Save the `Readability.js` file in the SAME directory as this HTML file.
    3. Uncomment the following line:
-->
<!-- <script src="readability.js"></script> -->


<script>
  // JavaScript remains the same as the previous version
  const urlInput = document.getElementById('url-input');
  const extractButton = document.getElementById('extract-button');
  const loadingIndicator = document.getElementById('loading-indicator');
  const extractedText = document.getElementById('extracted-text');
  const copyButton = document.getElementById('copy-button');
  const errorMessage = document.getElementById('error-message');
  const successMessage = document.getElementById('success-message');

  extractButton.addEventListener('click', handleExtraction);
  copyButton.addEventListener('click', copyTextToClipboard);

  function handleExtraction() {
    resetUI();

    const inputText = urlInput.value.trim();
    if (!inputText) {
        displayError("Please enter text containing a URL.");
        return;
    }

    const urlRegex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
    const match = inputText.match(urlRegex);

    if (!match) {
      displayError("No valid URL found in the input.");
      return;
    }

    const targetUrl = match[0];
    console.log("Extracted URL:", targetUrl);

    const corsProxyUrl = 'https://api.allorigins.win/raw?url=';
    const proxiedUrl = corsProxyUrl + encodeURIComponent(targetUrl);

    loadingIndicator.style.display = 'block';
    extractButton.disabled = true;

    fetch(proxiedUrl)
      .then(response => {
        if (!response.ok) {
          let errorMsg = `Proxy fetch failed: ${response.status} ${response.statusText}`;
          if (response.status === 404) errorMsg += ". URL not found via proxy.";
          else if (response.status === 403) errorMsg += ". Access denied (proxy blocked?).";
          else if (response.status >= 500) errorMsg += ". Proxy server error.";
          throw new Error(errorMsg);
        }
        return response.text();
      })
      .then(html => {
        let doc;
        try {
            const parser = new DOMParser();
            doc = parser.parseFromString(html, 'text/html');
        } catch (parseError) {
            console.error("DOM Parsing Error:", parseError);
            throw new Error("Failed to parse the HTML content.");
        }

        let article = null;
        if (typeof Readability === 'undefined') {
            console.warn("Readability.js not loaded. Falling back.");
            displayError("Readability.js script not loaded. Using basic fallback.");
        } else {
            try {
                 const documentClone = doc.cloneNode(true);
                 let reader = new Readability(documentClone);
                 article = reader.parse();
            } catch (readabilityError) {
                console.error("Readability Error:", readabilityError);
                displayError("Readability.js failed. Trying basic fallback.");
            }
        }

        if (article && article.textContent && article.textContent.trim().length > 100) {
            extractedText.value = article.textContent.trim();
            displaySuccess("Extracted using Readability.");
            enableCopyButton();
        } else {
            console.log("Readability failed/insufficient, attempting fallback...");
            const mainElement = doc.querySelector('main') || doc.querySelector('article') || doc.querySelector('.post-content') || doc.querySelector('.entry-content') || doc.body;

            if (mainElement) {
                const scripts = mainElement.querySelectorAll('script, style, nav, header, footer, aside, .sidebar, .ads, [aria-hidden="true"]'); // Added more elements to remove
                scripts.forEach(el => el.remove());
                extractedText.value = mainElement.textContent.trim();
            } else {
                 extractedText.value = doc.body ? doc.body.textContent.trim() : '';
            }

            if (extractedText.value.trim().length > 50) {
                 displaySuccess("Extracted using basic fallback.");
                 enableCopyButton();
            } else {
                 displayError("Extraction failed: Could not get meaningful content.");
                 extractedText.value = '';
                 copyButton.disabled = true;
            }
        }
      })
      .catch(error => {
        console.error("Error during fetch or extraction:", error);
        displayError(`Error: ${error.message}`);
      })
      .finally(() => {
        loadingIndicator.style.display = 'none';
        extractButton.disabled = false;
      });
  }

  function copyTextToClipboard() {
    if (!extractedText.value) {
        displayError("Nothing to copy.");
        return;
    }

    navigator.clipboard.writeText(extractedText.value)
      .then(() => {
        displaySuccess("Content copied to clipboard!");
      })
      .catch(err => {
        console.error('Failed to copy text: ', err);
        try {
            extractedText.select();
            document.execCommand('copy');
            displaySuccess("Copied (using fallback)!");
        } catch (execErr) {
             displayError("Failed to copy automatically.");
        }
      });
  }

  function resetUI() {
    errorMessage.textContent = '';
    successMessage.textContent = '';
    loadingIndicator.style.display = 'none';
    extractButton.disabled = false;
    // Decide if you want to clear text/disable copy on new attempt
    // extractedText.value = '';
    // copyButton.disabled = true;
  }

  function displayError(message) {
    errorMessage.textContent = message;
    successMessage.textContent = '';
  }

  function displaySuccess(message) {
    successMessage.textContent = message;
    errorMessage.textContent = '';
  }

  function enableCopyButton() {
    if(extractedText.value.trim()){
        copyButton.disabled = false;
    } else {
        copyButton.disabled = true;
    }
  }

</script>

</body>
</html>